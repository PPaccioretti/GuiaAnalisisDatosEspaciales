<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Sección 5 Implementación con R | Guía para el análisis de datos espaciales. Aplicaciones en agricultura</title>
  <meta name="description" content="DISEMINACIÓN CIENTÍFICA Y TRASNFERENCIA DE RESULTADOS DE INVESTIGACIÓN, PROMOVIDAS POR EL MINISTERIO DE CIENCIA Y TECNOLOGÍA DE LA PROVINCIA DE CÓRDOBA." />
  <meta name="generator" content="bookdown 0.17 and GitBook 2.6.7" />

  <meta property="og:title" content="Sección 5 Implementación con R | Guía para el análisis de datos espaciales. Aplicaciones en agricultura" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="DISEMINACIÓN CIENTÍFICA Y TRASNFERENCIA DE RESULTADOS DE INVESTIGACIÓN, PROMOVIDAS POR EL MINISTERIO DE CIENCIA Y TECNOLOGÍA DE LA PROVINCIA DE CÓRDOBA." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Sección 5 Implementación con R | Guía para el análisis de datos espaciales. Aplicaciones en agricultura" />
  
  <meta name="twitter:description" content="DISEMINACIÓN CIENTÍFICA Y TRASNFERENCIA DE RESULTADOS DE INVESTIGACIÓN, PROMOVIDAS POR EL MINISTERIO DE CIENCIA Y TECNOLOGÍA DE LA PROVINCIA DE CÓRDOBA." />
  

<meta name="author" content="Mariano Córdoba" />
<meta name="author" content="Pablo Paccioretti" />
<meta name="author" content="Franca Giannini Kurina" />
<meta name="author" content="Cecilia Bruno" />
<meta name="author" content="Mónica Balzarini" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="predicción-con-múltiples-capas-de-datos.html"/>
<link rel="next" href="implementación-con-infostat.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-154490537-1', 'auto');
  ga('send', 'pageview');

</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
<link rel="stylesheet" href="css/toc2.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Guía para el análisis de datos espaciales en agricultura</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Prólogo</a></li>
<li class="part"><span><b>I Aproximaciones metodológicas</b></span></li>
<li class="chapter" data-level="1" data-path="manejo-de-datos-espaciales.html"><a href="manejo-de-datos-espaciales.html"><i class="fa fa-check"></i><b>1</b> Manejo de datos espaciales</a><ul>
<li class="chapter" data-level="1.1" data-path="manejo-de-datos-espaciales.html"><a href="manejo-de-datos-espaciales.html#transformación-y-conversión-de-coordenadas"><i class="fa fa-check"></i><b>1.1</b> Transformación y conversión de coordenadas</a></li>
<li class="chapter" data-level="1.2" data-path="manejo-de-datos-espaciales.html"><a href="manejo-de-datos-espaciales.html#manipulación-de-múltiples-capas-de-datos"><i class="fa fa-check"></i><b>1.2</b> Manipulación de múltiples capas de datos</a></li>
<li class="chapter" data-level="1.3" data-path="manejo-de-datos-espaciales.html"><a href="manejo-de-datos-espaciales.html#depuración-de-datos"><i class="fa fa-check"></i><b>1.3</b> Depuración de datos</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html"><i class="fa fa-check"></i><b>2</b> Caracterización de variabilidad espacial</a><ul>
<li class="chapter" data-level="2.1" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html#semivariogramas"><i class="fa fa-check"></i><b>2.1</b> Semivariogramas</a><ul>
<li class="chapter" data-level="2.1.1" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html#ajuste-de-semivariogramas"><i class="fa fa-check"></i><b>2.1.1</b> Ajuste de semivariogramas</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html#correlación-espacial-bivariada"><i class="fa fa-check"></i><b>2.2</b> Correlación espacial bivariada</a><ul>
<li class="chapter" data-level="2.2.1" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html#coeficiente-de-correlación"><i class="fa fa-check"></i><b>2.2.1</b> Coeficiente de correlación</a></li>
<li class="chapter" data-level="2.2.2" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html#coeficiente-de-co-dispersión"><i class="fa fa-check"></i><b>2.2.2</b> Coeficiente de co-dispersión</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html#interpolación-kriging"><i class="fa fa-check"></i><b>2.3</b> Interpolación Kriging</a><ul>
<li class="chapter" data-level="2.3.1" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html#kriging-ordinario"><i class="fa fa-check"></i><b>2.3.1</b> Kriging ordinario</a></li>
<li class="chapter" data-level="2.3.2" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html#kriging-en-bloques"><i class="fa fa-check"></i><b>2.3.2</b> Kriging en bloques</a></li>
<li class="chapter" data-level="2.3.3" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html#kriging-local"><i class="fa fa-check"></i><b>2.3.3</b> Kriging local</a></li>
<li class="chapter" data-level="2.3.4" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html#kriging-universal"><i class="fa fa-check"></i><b>2.3.4</b> Kriging universal</a></li>
<li class="chapter" data-level="2.3.5" data-path="caracterización-de-variabilidad-espacial.html"><a href="caracterización-de-variabilidad-espacial.html#validación-cruzada"><i class="fa fa-check"></i><b>2.3.5</b> Validación cruzada</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="caracterización-de-variabilidad-espacial-con-múltiples-capas-de-datos.html"><a href="caracterización-de-variabilidad-espacial-con-múltiples-capas-de-datos.html"><i class="fa fa-check"></i><b>3</b> Caracterización de variabilidad espacial con múltiples capas de datos</a><ul>
<li class="chapter" data-level="3.1" data-path="caracterización-de-variabilidad-espacial-con-múltiples-capas-de-datos.html"><a href="caracterización-de-variabilidad-espacial-con-múltiples-capas-de-datos.html#análisis-de-componentes-principales"><i class="fa fa-check"></i><b>3.1</b> Análisis de componentes principales</a></li>
<li class="chapter" data-level="3.2" data-path="caracterización-de-variabilidad-espacial-con-múltiples-capas-de-datos.html"><a href="caracterización-de-variabilidad-espacial-con-múltiples-capas-de-datos.html#análisis-de-conglomerados"><i class="fa fa-check"></i><b>3.2</b> Análisis de conglomerados</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="predicción-con-múltiples-capas-de-datos.html"><a href="predicción-con-múltiples-capas-de-datos.html"><i class="fa fa-check"></i><b>4</b> Predicción con múltiples capas de datos</a><ul>
<li class="chapter" data-level="4.1" data-path="predicción-con-múltiples-capas-de-datos.html"><a href="predicción-con-múltiples-capas-de-datos.html#regresión-con-errores-correlacionados-espacialmente-vía-reml"><i class="fa fa-check"></i><b>4.1</b> Regresión con errores correlacionados espacialmente vía REML</a></li>
<li class="chapter" data-level="4.2" data-path="predicción-con-múltiples-capas-de-datos.html"><a href="predicción-con-múltiples-capas-de-datos.html#regresión-con-efectos-aleatorios-de-sitio-vía-inla"><i class="fa fa-check"></i><b>4.2</b> Regresión con efectos aleatorios de sitio vía INLA</a></li>
<li class="chapter" data-level="4.3" data-path="predicción-con-múltiples-capas-de-datos.html"><a href="predicción-con-múltiples-capas-de-datos.html#regresión-vía-modelos-basados-en-árbol"><i class="fa fa-check"></i><b>4.3</b> Regresión vía modelos basados en árbol</a><ul>
<li class="chapter" data-level="4.3.1" data-path="predicción-con-múltiples-capas-de-datos.html"><a href="predicción-con-múltiples-capas-de-datos.html#bosques-aleatorios"><i class="fa fa-check"></i><b>4.3.1</b> Bosques aleatorios</a></li>
<li class="chapter" data-level="4.3.2" data-path="predicción-con-múltiples-capas-de-datos.html"><a href="predicción-con-múltiples-capas-de-datos.html#árboles-de-regresión-generalizados"><i class="fa fa-check"></i><b>4.3.2</b> Árboles de regresión generalizados</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>II Análisis de datos a escala fina</b></span></li>
<li class="chapter" data-level="5" data-path="implementación-con-r.html"><a href="implementación-con-r.html"><i class="fa fa-check"></i><b>5</b> Implementación con R</a><ul>
<li class="chapter" data-level="5.1" data-path="implementación-con-r.html"><a href="implementación-con-r.html#conversión-de-coordenadas-espaciales"><i class="fa fa-check"></i><b>5.1</b> Conversión de coordenadas espaciales</a></li>
<li class="chapter" data-level="5.2" data-path="implementación-con-r.html"><a href="implementación-con-r.html#eliminación-de-outliers-e-inliers"><i class="fa fa-check"></i><b>5.2</b> Eliminación de <em>outliers</em> e <em>inliers</em></a></li>
<li class="chapter" data-level="5.3" data-path="implementación-con-r.html"><a href="implementación-con-r.html#detección-de-tendencias-espaciales"><i class="fa fa-check"></i><b>5.3</b> Detección de tendencias espaciales</a></li>
<li class="chapter" data-level="5.4" data-path="implementación-con-r.html"><a href="implementación-con-r.html#cálculo-del-índice-de-moran"><i class="fa fa-check"></i><b>5.4</b> Cálculo del índice de Moran</a></li>
<li class="chapter" data-level="5.5" data-path="implementación-con-r.html"><a href="implementación-con-r.html#análisis-basado-en-semivariogramas"><i class="fa fa-check"></i><b>5.5</b> Análisis basado en semivariogramas</a><ul>
<li class="chapter" data-level="5.5.1" data-path="implementación-con-r.html"><a href="implementación-con-r.html#mapeo-de-la-variabilidad-espacial"><i class="fa fa-check"></i><b>5.5.1</b> Mapeo de la variabilidad espacial</a></li>
<li class="chapter" data-level="5.5.2" data-path="implementación-con-r.html"><a href="implementación-con-r.html#validación-cruzada-1"><i class="fa fa-check"></i><b>5.5.2</b> Validación cruzada</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="implementación-con-r.html"><a href="implementación-con-r.html#caracterización-de-variabilidad-espacial-con-múltiples-capas-de-datos-1"><i class="fa fa-check"></i><b>5.6</b> Caracterización de variabilidad espacial con múltiples capas de datos</a><ul>
<li class="chapter" data-level="5.6.1" data-path="implementación-con-r.html"><a href="implementación-con-r.html#análisis-de-componentes-principales-1"><i class="fa fa-check"></i><b>5.6.1</b> Análisis de componentes principales</a></li>
<li class="chapter" data-level="5.6.2" data-path="implementación-con-r.html"><a href="implementación-con-r.html#análisis-de-conglomerados-1"><i class="fa fa-check"></i><b>5.6.2</b> Análisis de conglomerados</a></li>
</ul></li>
<li class="chapter" data-level="5.7" data-path="implementación-con-r.html"><a href="implementación-con-r.html#predicción-con-múltiples-capas-de-datos-1"><i class="fa fa-check"></i><b>5.7</b> Predicción con múltiples capas de datos</a><ul>
<li class="chapter" data-level="5.7.1" data-path="implementación-con-r.html"><a href="implementación-con-r.html#kriging-con-deriva-externa"><i class="fa fa-check"></i><b>5.7.1</b> Kriging con deriva externa</a></li>
<li class="chapter" data-level="5.7.2" data-path="implementación-con-r.html"><a href="implementación-con-r.html#kriging-desde-modelo-de-regresión"><i class="fa fa-check"></i><b>5.7.2</b> Kriging desde modelo de regresión</a></li>
<li class="chapter" data-level="5.7.3" data-path="implementación-con-r.html"><a href="implementación-con-r.html#árboles-aleatorios"><i class="fa fa-check"></i><b>5.7.3</b> Árboles aleatorios</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html"><i class="fa fa-check"></i><b>6</b> Implementación con InfoStat</a><ul>
<li class="chapter" data-level="6.1" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#conversión-de-coordenadas-espaciales-1"><i class="fa fa-check"></i><b>6.1</b> Conversión de coordenadas espaciales</a></li>
<li class="chapter" data-level="6.2" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#eliminación-de-outliers-e-inliers-1"><i class="fa fa-check"></i><b>6.2</b> Eliminación de <em>outliers</em> e <em>inliers</em></a></li>
<li class="chapter" data-level="6.3" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#detección-de-tendencias-espaciales-1"><i class="fa fa-check"></i><b>6.3</b> Detección de tendencias espaciales</a></li>
<li class="chapter" data-level="6.4" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#cálculo-del-índice-de-moran-1"><i class="fa fa-check"></i><b>6.4</b> Cálculo del índice de Moran</a></li>
<li class="chapter" data-level="6.5" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#análisis-basado-en-semivariogramas-1"><i class="fa fa-check"></i><b>6.5</b> Análisis basado en semivariogramas</a><ul>
<li class="chapter" data-level="6.5.1" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#mapeo-de-variabilidad-espacial"><i class="fa fa-check"></i><b>6.5.1</b> Mapeo de variabilidad espacial</a></li>
<li class="chapter" data-level="6.5.2" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#validación-cruzada-2"><i class="fa fa-check"></i><b>6.5.2</b> Validación cruzada</a></li>
</ul></li>
<li class="chapter" data-level="6.6" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#caracterización-de-variabilidad-espacial-con-múltiples-capas-de-datos-2"><i class="fa fa-check"></i><b>6.6</b> Caracterización de variabilidad espacial con múltiples capas de datos</a><ul>
<li class="chapter" data-level="6.6.1" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#análisis-de-componentes-principales-2"><i class="fa fa-check"></i><b>6.6.1</b> Análisis de componentes principales</a></li>
<li class="chapter" data-level="6.6.2" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#análisis-de-conglomerados-2"><i class="fa fa-check"></i><b>6.6.2</b> Análisis de conglomerados</a></li>
</ul></li>
<li class="chapter" data-level="6.7" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#predicción-con-múltiples-capas-de-datos-2"><i class="fa fa-check"></i><b>6.7</b> Predicción con múltiples capas de datos</a><ul>
<li class="chapter" data-level="6.7.1" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#kriging-con-deriva-externa-1"><i class="fa fa-check"></i><b>6.7.1</b> Kriging con deriva externa</a></li>
<li class="chapter" data-level="6.7.2" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#kriging-desde-modelo-de-regresión-1"><i class="fa fa-check"></i><b>6.7.2</b> Kriging desde modelo de regresión</a></li>
<li class="chapter" data-level="6.7.3" data-path="implementación-con-infostat.html"><a href="implementación-con-infostat.html#árboles-aleatorios-1"><i class="fa fa-check"></i><b>6.7.3</b> Árboles aleatorios</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>III Análisis de datos a escala regional</b></span></li>
<li class="chapter" data-level="7" data-path="bases-de-datos-regionales.html"><a href="bases-de-datos-regionales.html"><i class="fa fa-check"></i><b>7</b> Bases de datos regionales</a><ul>
<li class="chapter" data-level="7.1" data-path="bases-de-datos-regionales.html"><a href="bases-de-datos-regionales.html#manejo-de-datos-espaciales-1"><i class="fa fa-check"></i><b>7.1</b> Manejo de datos espaciales</a></li>
<li class="chapter" data-level="7.2" data-path="bases-de-datos-regionales.html"><a href="bases-de-datos-regionales.html#confección-de-grillas-de-predicción"><i class="fa fa-check"></i><b>7.2</b> Confección de grillas de predicción</a></li>
<li class="chapter" data-level="7.3" data-path="bases-de-datos-regionales.html"><a href="bases-de-datos-regionales.html#agregado-de-capas-de-información"><i class="fa fa-check"></i><b>7.3</b> Agregado de capas de información</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="predicción-con-múltiples-capas-de-datos-3.html"><a href="predicción-con-múltiples-capas-de-datos-3.html"><i class="fa fa-check"></i><b>8</b> Predicción con múltiples capas de datos</a><ul>
<li class="chapter" data-level="8.1" data-path="predicción-con-múltiples-capas-de-datos-3.html"><a href="predicción-con-múltiples-capas-de-datos-3.html#regresión-con-errores-correlacionados-espacialmente-vía-reml-1"><i class="fa fa-check"></i><b>8.1</b> Regresión con errores correlacionados espacialmente vía REML</a></li>
<li class="chapter" data-level="8.2" data-path="predicción-con-múltiples-capas-de-datos-3.html"><a href="predicción-con-múltiples-capas-de-datos-3.html#regresión-con-efectos-aleatorios-de-sitio-vía-inla-1"><i class="fa fa-check"></i><b>8.2</b> Regresión con efectos aleatorios de sitio vía INLA</a></li>
<li class="chapter" data-level="8.3" data-path="predicción-con-múltiples-capas-de-datos-3.html"><a href="predicción-con-múltiples-capas-de-datos-3.html#regresión-vía-modelos-basados-en-árbol-1"><i class="fa fa-check"></i><b>8.3</b> Regresión vía modelos basados en árbol</a></li>
</ul></li>
<li class="appendix"><span><b>Introducción a R</b></span></li>
<li class="chapter" data-level="A" data-path="herramientas-de-software.html"><a href="herramientas-de-software.html"><i class="fa fa-check"></i><b>A</b> Herramientas de software</a><ul>
<li class="chapter" data-level="A.1" data-path="herramientas-de-software.html"><a href="herramientas-de-software.html#introducción-al-manejo-de-datos-espaciales-con-r"><i class="fa fa-check"></i><b>A.1</b> Introducción al manejo de datos espaciales con R</a></li>
<li class="chapter" data-level="A.2" data-path="herramientas-de-software.html"><a href="herramientas-de-software.html#intérprete-de-r-en-infostat"><i class="fa fa-check"></i><b>A.2</b> Intérprete de R en InfoStat</a></li>
<li class="chapter" data-level="A.3" data-path="herramientas-de-software.html"><a href="herramientas-de-software.html#rstudio"><i class="fa fa-check"></i><b>A.3</b> RStudio</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="referencias.html"><a href="referencias.html"><i class="fa fa-check"></i>Referencias</a></li>
<li class="divider"></li>
<li><a href="https://www.agro.unc.edu.ar/~estadisticaaplicada" target="blank">Estadística Aplicada</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Guía para el análisis de datos espaciales. Aplicaciones en agricultura</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="implementación-con-r" class="section level1">
<h1><span class="header-section-number">Sección 5</span> Implementación con R</h1>
<p>A continuación, se muestran los procedimientos para realizar el análisis exploratorio utilizando datos de rendimiento de trigo (<strong>datosRinde.txt</strong>) con n=9810 observaciones que fueron recolectado con un monitor de rendimiento en un lote agrícola de 84 ha. La base de datos cuenta con tres columnas, las primeras dos identifican las coordenadas espaciales bidimensionales (x e y) y la tercera corresponde al rendimiento expresado en <span class="math inline">\(t\ ha^{-1}\)</span>. Para cargar una base de datos puede utilizarse la función <code>read.table()</code>. Esta función permite abrir distintos tipos de archivos entre ellos aquellos de extensión .txt. El siguiente ejemplo crea un objeto llamado “datos” de clase <code>data.frame</code> cuya información es leída desde un archivo de texto (.txt). El argumento <code>header=TRUE</code> indica que la primera fila de los datos contiene los nombres de las columnas.</p>
<p>Para seguir la ilustraciión, cargar los paquetes específicos de R que albergan las funciones que se utilizarán para el análisis.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sp)
<span class="kw">library</span>(sf)
<span class="kw">library</span>(tmap)
<span class="co">#&gt; Error : invalid version specification &#39;1,5&#39;</span>
<span class="kw">library</span>(e1071)
<span class="kw">library</span>(spdep)
<span class="kw">library</span>(gstat)
<span class="kw">library</span>(caret)
<span class="kw">library</span>(geoR)
<span class="kw">library</span>(nlme)
<span class="kw">library</span>(ade4)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;datos/datosRinde.txt&quot;</span>, 
                    <span class="dt">header =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>Para visualizar las filas de un objeto, basta con escribir su nombre o, en el caso de objetos de clase data.frame es posible utilizar la función <code>head()</code>. En el panel de resultados, se despliega el contenido del objeto.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(datos)
<span class="co">#&gt;       x     y Rinde</span>
<span class="co">#&gt; 1 -59,1 -37,9 0,348</span>
<span class="co">#&gt; 2 -59,1 -37,9 0,360</span>
<span class="co">#&gt; 3 -59,1 -37,9 0,367</span>
<span class="co">#&gt; 4 -59,1 -37,9 0,001</span>
<span class="co">#&gt; 5 -59,1 -37,9 0,382</span>
<span class="co">#&gt; 6 -59,1 -37,9 0,409</span></code></pre></div>
<div id="conversión-de-coordenadas-espaciales" class="section level2">
<h2><span class="header-section-number">5.1</span> Conversión de coordenadas espaciales</h2>
<p>Dado que la función utilizada para la generación del objeto <code>datos</code> no es específica para datos espaciales, es necesario transformar este objeto. Esta transformación permite correr funciones estadísticas que solo trabajan sobre objetos de datos espaciales (clase <code>SpatialPointsDataFrame</code> o <code>sf</code>). Para ello puede utilizarse funciones de los paquetes <code>sp</code> o <code>sf</code>.</p>
<p>La función <code>coordinates()</code> del paquete <code>sp</code> transforma el <code>data.frame</code> en un objeto de datos espaciales e indica al software que las columnas “x” e “y” son coordenadas espaciales. A continuación, se genera un nuevo objeto espacial denominado <code>datos_sp</code> que contiene esta información.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_sp &lt;-<span class="st"> </span>datos
<span class="kw">coordinates</span>(datos_sp) &lt;-<span class="st"> </span><span class="er">~</span>x<span class="op">+</span>y</code></pre></div>
<p>Luego de indicar las columnas que pertenecen a la información de las coordenadas, es necesario especificar el sistema de referencia. La función <code>CRS()</code>, Coordinate Reference System, tiene una variedad de argumentos que permiten hacer referencia a diferentes sistemas de proyecciones y asociar esta información al objeto con el que se está trabajando. La proyección <em>longlat</em> es utilizada en esta aplicación. Esta proyección solo admite valores de longitud mayores a -180 y menores a 180 y valores de latitudes que se encuentren entre -90 y 90. El <em>datum</em> especificado será WGS84.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">proj4string</span>(datos_sp) &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">CRS</span>(<span class="st">&quot;+proj=longlat +datum=WGS84&quot;</span>)</code></pre></div>
<p>Una alternativa para hacer referencia a un sistema de coordenadas particular es utilizar su código EPSG. La EPSG es una organización científica vinculada a la industria del petróleo europea (<a href="http://www.epsg-registry.org/" class="uri">http://www.epsg-registry.org/</a>) la cual desarrolló un repositorio que contiene información sobre sistemas de referencia, proyecciones cartográficas y elipsoides de todo el mundo. La función <code>make_EPSG()</code> del paquete <code>rgdal</code> permite visualizar todos ellos. Para realizar este procedimiento sólo se modifican los argumentos de la función CRS. En este caso el código EPSG para la proyección <em>longlat</em> es 4326.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">proj4string</span>(datos_sp) &lt;-<span class="st"> </span><span class="kw">CRS</span>(<span class="st">&quot;+init=epsg:4326&quot;</span>)</code></pre></div>
<p>La función <code>spTransform()</code> permite convertir las coordenadas. Cuando se realiza la transformación del sistema de proyección geográfico a cartesiano, es necesario indicar a cuál zona o faja pertenecen los datos bajo análisis, para este caso la zona es 21. Al igual que en la sentencia anterior, se debe indicar el <em>datum</em> y <em>elipsoide</em> que en ambos casos corresponde a WGS84.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_sp &lt;-
<span class="st">  </span><span class="kw">spTransform</span>(datos_sp,
              <span class="kw">CRS</span>(<span class="st">&quot;+proj=utm +zone=21 +south</span>
<span class="st">     +ellps=WGS84 +datum=WGS84&quot;</span>))</code></pre></div>
<p>Esta transformación también puede realizarse en base al código EPSG en este caso para el sistema de coordenadas UTM faja 21 sur el código es 32721.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_sp &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">spTransform</span>(datos_sp, 
              <span class="kw">CRS</span>(<span class="st">&quot;+init=epsg:32721&quot;</span>))</code></pre></div>
<p>Otra opción para generar este tipo de datos espaciales es utilizando el paquete <code>sf</code>. Para ello se usan las funciones <code>st_as_sf()</code> la cual convierte el <code>data.frame</code> en un objeto <code>sf</code> y se le asigna el sistema de coordenadas de referencia, utilizando el argumento <code>crs = 4326</code>. La función <code>st_transform()</code> transforma el sistema de coordenadas.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_sf &lt;-<span class="st"> </span><span class="kw">st_as_sf</span>(datos, 
                     <span class="dt">coords =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>), 
                     <span class="dt">crs =</span> <span class="dv">4326</span>)
<span class="kw">st_crs</span>(datos_sf) &lt;-<span class="st"> </span><span class="dv">4326</span>
datos_sf &lt;-<span class="st"> </span><span class="kw">st_transform</span>(datos_sf, <span class="dt">crs =</span> <span class="dv">32721</span>)</code></pre></div>
<p>Si se visualizan las primeras filas del objeto, se puede observar, entre otras cosas, la clase de objeto (<code>sf</code>), su geometría (puntos) y la información referida a su sistema de coordenadas.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(datos)
<span class="co">#&gt;       x     y Rinde</span>
<span class="co">#&gt; 1 -59,1 -37,9 0,348</span>
<span class="co">#&gt; 2 -59,1 -37,9 0,360</span>
<span class="co">#&gt; 3 -59,1 -37,9 0,367</span>
<span class="co">#&gt; 4 -59,1 -37,9 0,001</span>
<span class="co">#&gt; 5 -59,1 -37,9 0,382</span>
<span class="co">#&gt; 6 -59,1 -37,9 0,409</span></code></pre></div>
<p>Esta transformación también puede realizarse en base al código EPSG en este caso para el sistema de coordenadas UTM faja 21 sur el código es 32721.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_sp &lt;-<span class="st"> </span><span class="kw">spTransform</span>(datos_sp, 
                        <span class="kw">CRS</span>(<span class="st">&quot;+init=epsg:32721&quot;</span>))</code></pre></div>
<p>Otra opción para generar este tipo de datos espaciales es utilizando el paquete <code>sf</code>. Para ello se usan las funciones <code>st_as_sf()</code> (convierte el <code>data.frame</code> en un objeto de clase <code>sf</code>), <code>st_crs()</code> (asigna el sistema de coordenadas de referencia) y <code>st_transform()</code> (transforma el sistema de coordenadas).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_sf &lt;-<span class="st"> </span><span class="kw">st_as_sf</span>(datos, <span class="dt">coords=</span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>), 
                     <span class="dt">crs=</span><span class="dv">4326</span>)
datos_sf &lt;-<span class="st"> </span><span class="kw">st_transform</span>(datos_sf, <span class="dt">crs=</span><span class="dv">32721</span>)</code></pre></div>
<p>Si se visualizan las primeras filas del objeto, se puede observar entre otras cosas la clase de objeto (<code>sf</code>), su geometría (puntos) y la información referida a su sistema de coordenadas.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(datos_sf)
<span class="co">#&gt; Simple feature collection with 6 features</span>
and <span class="dv">1</span> field
<span class="co">#&gt; geometry type: POINT</span>
<span class="co">#&gt; dimension: XY</span>
<span class="co">#&gt; bbox: xmin: 312000 ymin: 5800000 xmax:</span>
<span class="dv">313000</span> ymax<span class="op">:</span><span class="st"> </span><span class="dv">5800000</span>
<span class="co">#&gt; epsg (SRID): 32721</span>
<span class="co">#&gt; proj4string: </span>
    <span class="op">+</span><span class="st"> </span>proj=utm 
    <span class="op">+</span><span class="st"> </span>zone=<span class="dv">21</span> 
    <span class="op">+</span><span class="st"> </span>south
<span class="op">+</span>datum=WGS84 <span class="op">+</span>units=m <span class="op">+</span>no_defs
<span class="co">#&gt; First 3 features:</span>
<span class="co">#&gt; Rinde geometry</span>
<span class="co">#&gt; 1 0,348 POINT (313088 5800921)</span>
<span class="co">#&gt; 2 0,360 POINT (311983 5800811)</span>
<span class="co">#&gt; 3 0,367 POINT (312933 5800910)</span></code></pre></div>
<p>La visualización de la información georreferenciada permite un rápido diagnóstico de la distribución de los datos y de los valores observados. Trabajando con datos de clase <code>sf</code> es posible realizar una rápida visualización de los datos espaciales. El paquete <code>tmap</code> permite realizar mapas temáticos. Para comenzar a realizar un mapa debe especificarse los datos con los que se desea trabajar mediante la función <code>tm_shape()</code> y luego se suman elementos creados con funciones de este paquete utilizando el símbolo <code>+</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tm_shape</span>(datos_sf) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="st">&quot;Rinde&quot;</span>,<span class="dt">title=</span><span class="st">&quot;Rendimiento (t/ha)&quot;</span>)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-18-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
</div>
<div id="eliminación-de-outliers-e-inliers" class="section level2">
<h2><span class="header-section-number">5.2</span> Eliminación de <em>outliers</em> e <em>inliers</em></h2>
<p>En un <code>data.frame</code>, una forma sencilla para obtener medidas resumen de una variable es con la función <code>summary()</code>. Se utiliza <code>$</code> para hacer referencia a una columna particular dentro de un objeto.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(datos_sf<span class="op">$</span>Rinde)
<span class="co">#&gt; Min. 1st Qu.  Median Mean 3rd Qu.  Max.</span>
<span class="co">#&gt; 0,00 3,71 4,68 4,62 5,48 24,00</span></code></pre></div>
<p>Las funciones <code>hist()</code> y <code>boxplot()</code> realizan gráficos de histogramas y box-plots, respectivamente. Sus múltiples argumentos permiten la edición de cada gráfico. La función <code>par()</code> permite dividir la ventana gráfica de R, en el siguiente ejemplo se divide la ventana gráfica de R en dos columnas y una fila.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))
<span class="kw">hist</span>(
  datos_sf<span class="op">$</span>Rinde,
  <span class="dt">col =</span> <span class="st">&#39;grey&#39;</span>,
  <span class="dt">nclass =</span> <span class="dv">20</span>,
  <span class="dt">main =</span> <span class="st">&quot;Histograma&quot;</span>,
  <span class="dt">ylab =</span> <span class="st">&#39;Frecuencia Relativa&#39;</span>,
  <span class="dt">xlab =</span> <span class="st">&#39;Rendimiento (t/ha)&#39;</span>
)

<span class="kw">boxplot</span>(
  datos<span class="op">$</span>Rinde,
  <span class="dt">col =</span> <span class="st">&#39;grey&#39;</span>,
  <span class="dt">ylab =</span> <span class="st">&#39;Rendimiento (t/ha)&#39;</span>,
  <span class="dt">main =</span> <span class="st">&quot;Box-Plot&quot;</span>,
  <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">14</span>)
)</code></pre></div>
<p><img src="figuras/figLibro/fighistBox-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>a función <code>skewness()</code> del paquete <code>e1071</code> permite calcular el coeficiente de asimetría. Existen 3 fórmulas para su cálculo (por defecto usa el tipo 3). Para más información, se puede utilizar <code>help(skewness)</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">skewness</span>(datos_sf<span class="op">$</span>Rinde)
<span class="co">#&gt; [1] 1,45</span></code></pre></div>
<p>En el histograma se observa asimetría derecha en la distribución de los datos. La asimetría también puede advertirse con los estadísticos con el coeficiente de asimetría el cual es de 1,45. En el gráfico box-plot se observan valores extremos de la variable que se encuentran principalmente por encima de la media <span class="math inline">\(+\)</span> 3 SD.</p>
<p>Las siguientes instrucciones calculan y crean objetos para la media, el DE y los límites superior (<span class="math inline">\(media + 3DE\)</span>) e inferior (<span class="math inline">\(media - 3DE\)</span>) con los que pueden detectarse los <em>outliers</em> y elimina estos valores.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Media &lt;-<span class="st"> </span><span class="kw">mean</span>(datos_sf<span class="op">$</span>Rinde)
DE &lt;-<span class="st"> </span><span class="kw">sd</span>(datos_sf<span class="op">$</span>Rinde)
LI &lt;-<span class="st"> </span>Media<span class="dv">-3</span><span class="op">*</span>DE
LS &lt;-<span class="st"> </span>Media<span class="op">+</span><span class="dv">3</span><span class="op">*</span>DE</code></pre></div>
<p>Los símbolos <code>|</code> y <code>&amp;</code> son operadores lógicos que significan <em>or</em> y <em>and</em>, respectivamente. Las siguientes instrucciones generan dos objetos. El objeto <code>datos_1</code> es la base depurada, es decir sin <em>outliers</em>, mientras que el objeto <code>outliers</code> presenta los datos que han sido eliminados en esta etapa.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_<span class="dv">1</span> &lt;-
<span class="st">  </span><span class="kw">subset</span>(datos_sf, 
         datos_sf<span class="op">$</span>Rinde <span class="op">&lt;</span><span class="st"> </span>LS <span class="op">&amp;</span><span class="st"> </span>
<span class="st">           </span>datos_sf<span class="op">$</span>Rinde <span class="op">&gt;</span><span class="st"> </span>LI)
outliers &lt;-
<span class="st">  </span><span class="kw">subset</span>(datos_sf, 
         datos_sf<span class="op">$</span>Rinde <span class="op">&gt;</span><span class="st"> </span>LS <span class="op">|</span><span class="st"> </span>
<span class="st">           </span>datos_sf<span class="op">$</span>Rinde <span class="op">&lt;</span><span class="st"> </span>LI)</code></pre></div>
<p>Para ver el impacto de la eliminación de <em>outliers</em> pueden obtenerse nuevamente las medidas resumen, coeficiente de asimetría, histograma y box-plot.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(datos_<span class="dv">1</span><span class="op">$</span>Rinde)
<span class="co">#&gt; Min. 1st Qu.  Median Mean 3rd Qu.  Max.</span>
<span class="co">#&gt; 0,35 3,69 4,66 4,52 5,45 8,73</span>
<span class="kw">skewness</span>(datos_<span class="dv">1</span><span class="op">$</span>Rinde)
<span class="co">#&gt; [1] -0,536</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))
<span class="kw">hist</span>(
  datos_<span class="dv">1</span><span class="op">$</span>Rinde,
  <span class="dt">col =</span> <span class="st">&#39;grey&#39;</span>,
  <span class="dt">nclass =</span> <span class="dv">20</span>,
  <span class="dt">main =</span> <span class="st">&quot;Histograma&quot;</span>,
  <span class="dt">ylab =</span> <span class="st">&#39;Frecuencia Relativa&#39;</span>,
  <span class="dt">xlab =</span> <span class="st">&#39;Rinde (t/ha)&#39;</span>
)
<span class="kw">boxplot</span>(
  datos_<span class="dv">1</span><span class="op">$</span>Rinde,
  <span class="dt">col =</span> <span class="st">&#39;grey&#39;</span>,
  <span class="dt">ylab =</span> <span class="st">&#39;Rinde (t/ha)&#39;</span>,
  <span class="dt">main =</span> <span class="st">&quot;Box-Plot&quot;</span>,
  <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">14</span>)
)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-25-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>Las medidas resumen muestran un cambio principalmente a nivel de los valores máximos, pasando de 24 a 8,734 <span class="math inline">\(t\ ha^{-1}\)</span>. El coeficiente de asimetría presenta un valor de -0,54 que se aproxima a valores recomendados para el análisis geoestadístico (-1 a 1). En la figura anterior se presenta el histograma y box-plot luego de la eliminación de los <em>outliers</em>. Para la variable en análisis, se eliminaron durante la depuración 120 casos que representan un 1,2% del total de sitios (n=9810) con mediciones. Puede observarse una mejora en la simetría de la distribución de la variable y una marcada disminución de valores extremos.</p>
<p>La identificación y eliminación de <em>inliers</em> requiere de la creación de una matriz de ponderación espacial. La función <code>dnearneigh()</code> se utiliza para identificar el vecindario de cada sitio. Para ello es necesario calcular la distancia espacial entre los puntos para lo cual se usa la sintaxis <code>$geom</code> que permite acceder a las coordenadas del objeto <code>datos</code>. En este ejemplo, se consideran datos vecinos a aquellos que se encuentran a una distancia Euclídea de 0 a 15 m. La función <code>nb2listw()</code> transforma el objeto <code>vecindarios</code> que contiene las distancias a una matriz de pesos estandarizados por filas (<code>style = &quot;W&quot;</code>). Este objeto es denominado <code>pesos_sp</code>. Para generar la matriz de pesos espaciales es necesario que todos los puntos tengan al menos un vecino, caso contario la función <code>nb2listw()</code> genera un error advirtiendo este hecho. Para superar el inconveniente es posible probar con distancias mayores hasta lograr que todos los puntos tengan al menos un vecino. Hay que tener la precaución de no generar un excesivo solapamiento entre los vecindarios. Otra opción es incorporar el argumento <code>zero.policy=T</code> dentro de la función <code>nb2listw()</code> que permite generar la matriz de pesos espaciales con observaciones que no presentan dato/s vecino/s. El mismo argumento debe agregarse luego cuando se calcula el índice de Moran local o gráfico de Moran (funciones <code>localmoran()</code> y <code>moran.plot()</code>, respectivamente). Las frecuencias del número de puntos vecinos para cada observación puede obtenerse mediante la función <code>summary()</code> del objeto <code>vecindarios</code>. En el ejemplo se observa que 3113 puntos tienen vecindarios conformados con 4 datos. Mientras que sólo un dato presenta 18 observaciones consideradas como vecinas.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">vecindarios &lt;-<span class="st"> </span><span class="kw">dnearneigh</span>(datos_<span class="dv">1</span><span class="op">$</span>geom,
                          <span class="dt">d1 =</span> <span class="dv">0</span>, <span class="dt">d2 =</span> <span class="dv">15</span>)
<span class="kw">summary</span>(vecindarios)
<span class="co">#&gt; Neighbour list object:</span>
<span class="co">#&gt; Number of regions: 9690</span>
<span class="co">#&gt; Number of nonzero links: 62578</span>
<span class="co">#&gt; Percentage nonzero weights: 0,0666</span>
<span class="co">#&gt; Average number of links: 6,46</span>
<span class="co">#&gt; Link number distribution:</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</span>
<span class="co">#&gt; 5 83 302 3113 1292 999 893 870 393 457 547</span>
<span class="dv">473</span> <span class="dv">171</span> <span class="dv">43</span> <span class="dv">31</span> <span class="dv">13</span> <span class="dv">4</span>
<span class="co">#&gt; 18</span>
<span class="co">#&gt; 1</span>
<span class="co">#&gt; 5 least connected regions:</span>
<span class="co">#&gt; 3033 7885 9153 9598 9681 with 1 link</span>
<span class="co">#&gt; 1 most connected region:</span>
<span class="co">#&gt; 869 with 18 links</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pesos_sp &lt;-<span class="st"> </span><span class="kw">nb2listw</span>(vecindarios,
                     <span class="dt">style =</span> <span class="st">&quot;W&quot;</span>)</code></pre></div>
<p>La función <code>localmoran()</code> calcula el índice local de Moran que permite identificar potenciales <em>outliers</em> espaciales. También permite el ajuste de los <em>valores-p</em> por el criterio de Bonferroni. La información referida al valor del índice local de Moran de cada punto se encuentra en la columna <code>Ii</code> mientras que su significancia estadística en la columna <code>Pr(z &lt; 0)</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">moranl &lt;-
<span class="st">  </span><span class="kw">localmoran</span>(datos_<span class="dv">1</span><span class="op">$</span>Rinde,
             pesos_sp,
             <span class="dt">p.adjust.method =</span> <span class="st">&quot;bonferroni&quot;</span>,
             <span class="dt">alternative =</span> <span class="st">&quot;less&quot;</span>)
<span class="kw">head</span>(moranl)
<span class="co">#&gt;     Ii      E.Ii Var.Ii  Z.Ii Pr(z &lt; 0)</span>
<span class="co">#&gt; 1 5,32 -0,000103 0,0832 18,44         1</span>
<span class="co">#&gt; 2 6,83 -0,000103 0,1110 20,49         1</span>
<span class="co">#&gt; 3 5,83 -0,000103 0,0832 20,21         1</span>
<span class="co">#&gt; 4 3,36 -0,000103 0,1665  8,24         1</span>
<span class="co">#&gt; 5 3,91 -0,000103 0,1427 10,35         1</span>
<span class="co">#&gt; 6 4,21 -0,000103 0,0999 13,31         1</span></code></pre></div>
<p>El gráfico de Moran permite la identificación de puntos influyentes. La función <code>moran.plot()</code> construye el gráfico y devuelve los estadísticos de diagnóstico para cada punto. En el eje horizontal se expresan los valores de la variable rendimiento mientras que en el vertical se representa el retardo espacial de la variable. Adicionalmente, se ajusta y añade a este diagrama modelos de regresión lineal y estadísticos de influencia para identificar sitios con datos raros. Un punto se determina como influyente si al menos uno de los estadísticos así lo considera. En la figura siguiente los puntos negros con forma romboidal fueron identificados como influyentes y se los considera como <em>inliers</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">moranp &lt;-
<span class="st">  </span><span class="kw">moran.plot</span>(
    datos_<span class="dv">1</span><span class="op">$</span>Rinde,
    <span class="dt">col =</span> <span class="dv">3</span>,
    pesos_sp,
    <span class="dt">labels =</span> F,
    <span class="dt">quiet =</span> T,
    <span class="dt">xlab =</span> <span class="st">&quot;Rinde&quot;</span>,
    <span class="dt">ylab =</span> <span class="st">&quot;Rinde Spatially Lagged&quot;</span>
  )</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-29-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>Para visualizar en una tabla los puntos potencialmente influyentes y sus estadísticos de diagnóstico puede imprimir el objeto <code>moranp</code>. Datos con * en la columna inf se los considera como influyente y por lo tanto posible <em>outlier</em> espacial.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(moranp)</code></pre></div>
<p>Desde el objeto <code>moranp</code> puede extraerse una matriz de valores lógicos (verdadero/falso) para los estadísticos diagnóstico que identifican un punto como influyente o no.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">influ &lt;-<span class="st"> </span>moranp<span class="op">$</span>is.inf
<span class="kw">head</span>(influ)
<span class="co">#&gt; dfb.1_ dfb.x dffit cov.r cook.d hat</span>
<span class="co">#&gt; 1 FALSE FALSE TRUE TRUE FALSE TRUE</span>
<span class="co">#&gt; 2 FALSE FALSE FALSE TRUE FALSE TRUE</span>
<span class="co">#&gt; [ reached getOption(&quot;max.print&quot;) -- omitted</span>
<span class="dv">4</span> rows ]</code></pre></div>
<p>En la siguiente sentencia se adiciona al objeto <code>datos_1</code> los valores de los objetos <code>moranl</code> e <code>influ</code>, que tienen información para detectar los <em>outliers</em> espaciales detectados con el índice de Moran local y gráfico de Moran, respectivamente.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">cbind</span>(datos_<span class="dv">1</span>, moranl, influ)</code></pre></div>
<p>Posteriormente procedemos a eliminar los datos con Índice de Moran Local negativo y estadísticamente significativos (p&lt;0,05). La función <code>subset()</code> selecciona datos que cumplen con cierta condición lógica. El operador lógico <em>or</em> que indica que extraiga los datos que cumplen con alguna de las dos condiciones. El nuevo objeto es denominado <code>datos_2</code>. Además, se crea un nuevo objeto que tendrá los datos que han sido eliminados en este proceso (<code>inliers_ml</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_<span class="dv">2</span> &lt;-
<span class="st">  </span><span class="kw">subset</span>(datos_<span class="dv">1</span>, 
         datos_<span class="dv">1</span>[[<span class="st">&quot;Ii&quot;</span>]] <span class="op">&gt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">|</span><span class="st"> </span>
<span class="st">           </span>datos_<span class="dv">1</span>[[<span class="st">&quot;Pr.z...0.&quot;</span>]] <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.05</span>)
inliers_ml &lt;-
<span class="st">  </span><span class="kw">subset</span>(datos_<span class="dv">1</span>, 
         datos_<span class="dv">1</span>[[<span class="st">&quot;Ii&quot;</span>]] <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span>
<span class="st">           </span>datos_<span class="dv">1</span>[[<span class="st">&quot;Pr.z...0.&quot;</span>]] <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>)</code></pre></div>
<p>Existen varias formas de eliminar las filas de la tabla que fueron identificadas como <em>inliers</em> con la función <code>moran.plot()</code>. Una alternativa es usando sentencias lógicas con los operadores <code>==</code> y <code>&amp;</code> que significan igualdad lógica y <em>and</em> respectivamente. Como en el caso anterior se genera una nueva base (<code>datos_3</code>) la cual no tendrá los datos considerados como <em>outliers</em> y <em>outliers</em> espaciales. También se genera una nueva base que tendrá solo los datos considerados aquí como <em>outliers</em> espaciales (<code>inliers_mp</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_<span class="dv">3</span> &lt;-
<span class="st">  </span>datos_<span class="dv">2</span>[datos_<span class="dv">2</span><span class="op">$</span>dfb<span class="fl">.1</span>_ <span class="op">==</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">&amp;</span>
<span class="st">            </span>datos_<span class="dv">2</span><span class="op">$</span>dfb.x <span class="op">==</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">&amp;</span><span class="st"> </span>
<span class="st">            </span>datos_<span class="dv">2</span><span class="op">$</span>dffit <span class="op">==</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">&amp;</span>
<span class="st">            </span>datos_<span class="dv">2</span><span class="op">$</span>cov.r <span class="op">==</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">&amp;</span>
<span class="st">            </span>datos_<span class="dv">2</span><span class="op">$</span>cook.d  <span class="op">==</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">&amp;</span><span class="st"> </span>
<span class="st">            </span>datos_<span class="dv">2</span><span class="op">$</span>hat <span class="op">==</span><span class="st"> </span><span class="ot">FALSE</span>, ]</code></pre></div>
<p>La sentencia anterior instruye al software para que cree un objeto llamado <code>datos_3</code> a partir de las filas del objeto <code>datos_2</code> cuyas columnas <code>dfb.1</code>, <code>dfb.x</code>, <code>dffit</code>, <code>cov.r</code>, <code>cook.d</code> y <code>hat</code> son simultáneamente iguales a <code>FALSE</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">inliers_mp &lt;-
<span class="st">  </span>datos_<span class="dv">2</span>[datos_<span class="dv">2</span><span class="op">$</span>dfb<span class="fl">.1</span>_ <span class="op">!=</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">|</span>
<span class="st">            </span>datos_<span class="dv">2</span><span class="op">$</span>dfb.x <span class="op">!=</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">|</span>
<span class="st">            </span>datos_<span class="dv">2</span><span class="op">$</span>dffit <span class="op">!=</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">|</span>
<span class="st">            </span>datos_<span class="dv">2</span><span class="op">$</span>cov.r <span class="op">!=</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">|</span>
<span class="st">            </span>datos_<span class="dv">2</span><span class="op">$</span>cook.d  <span class="op">!=</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">|</span><span class="st"> </span>
<span class="st">            </span>datos_<span class="dv">2</span><span class="op">$</span>hat <span class="op">!=</span><span class="st"> </span><span class="ot">FALSE</span>, ]</code></pre></div>
<p>Luego de identificar y eliminar los <em>inliers</em> detectados con el índice de Moran y posteriormente con el gráfico de Moran, la nueva base de datos presenta 9009 casos, es decir, se eliminaron 681 casos (7% de los datos) respecto a la base sin <em>outliers</em>.</p>
<p>Los estadísticos descriptivos de los datos depurados muestran una mejora en el coeficiente de asimetría (-0,19) lo cual se refleja en el histograma y box-plot. Este último también muestra la ausencia de valores extremos.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(datos_<span class="dv">3</span><span class="op">$</span>Rinde)
<span class="co">#&gt; Min. 1st Qu.  Median Mean 3rd Qu.  Max.</span>
<span class="co">#&gt; 1,73 3,81 4,72 4,63 5,46 7,32</span>
<span class="kw">skewness</span>(datos_<span class="dv">3</span><span class="op">$</span>Rinde)
<span class="co">#&gt; [1] -0,197</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))
<span class="kw">hist</span>(
  datos_<span class="dv">3</span><span class="op">$</span>Rinde,
  <span class="dt">col =</span> <span class="st">&#39;grey&#39;</span>,
  <span class="dt">nclass =</span> <span class="dv">20</span>,
  <span class="dt">main =</span> <span class="st">&quot;Histograma&quot;</span>,
  <span class="dt">ylab =</span> <span class="st">&#39;Frecuencia Relativa&#39;</span>,
  <span class="dt">xlab =</span> <span class="st">&#39;Rendimiento (t/ha)&#39;</span>
)
<span class="kw">boxplot</span>(
  datos_<span class="dv">3</span><span class="op">$</span>Rinde,
  <span class="dt">col =</span> <span class="st">&#39;grey&#39;</span>,
  <span class="dt">ylab =</span> <span class="st">&#39;Rendimiento (t/ha)&#39;</span>,
  <span class="dt">main =</span> <span class="st">&quot;Box-Plot&quot;</span>,
  <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">14</span>)
)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-39-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>Las siguientes líneas muestran la visualización conjunta de los datos originales y aquellos detectados como <em>outliers</em> y <em>outliers</em> espaciales. En este último se diferencian los detectados por el índice de Moran local (<em>Inliers</em> ML) respecto a los identificados por el gráfico de Moran (<em>Inliers</em> MP).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="kw">tmap_mode</span>(<span class="st">&quot;plot&quot;</span>)
<span class="co">#&gt; tmap mode set to plotting</span>
<span class="kw">tm_shape</span>(datos_<span class="dv">3</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="st">&quot;Rinde&quot;</span>, <span class="dt">title=</span><span class="st">&quot;Rendimiento (t/ha)&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_shape</span>(outliers) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">size =</span> <span class="fl">0.1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_shape</span>(inliers_ml) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>, <span class="dt">size =</span> <span class="fl">0.1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_shape</span>(inliers_mp) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="st">&quot;cyan&quot;</span>, <span class="dt">size =</span> <span class="fl">0.1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_add_legend</span>(<span class="st">&quot;symbol&quot;</span>, 
                <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;red&quot;</span>, <span class="st">&quot;blue&quot;</span>, <span class="st">&quot;cyan&quot;</span>), 
                <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;Outliers&quot;</span>, 
                           <span class="st">&quot;Inliers ML&quot;</span>, 
                           <span class="st">&quot;Inliers MP&quot;</span>))</code></pre></div>
<p><img src="figuras/figLibro/tmapvarios-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>Finalmente las líneas siguientes permiten la exportación de los datos depurados en diferentes formatos (.csv, .shp, .gpkg). para ello se utiliza la función <code>st_write()</code>. Previo a ello se selecciona solo la variable Rinde del objeto <code>datos_3</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_<span class="dv">3</span> &lt;-<span class="st"> </span>datos_<span class="dv">3</span>[, <span class="kw">c</span>(<span class="st">&quot;Rinde&quot;</span>)]
<span class="kw">st_write</span>(datos_<span class="dv">3</span>,
         <span class="st">&quot;base_depurada.csv&quot;</span>,
         <span class="dt">layer_options =</span> <span class="st">&quot;GEOMETRY=AS_XY&quot;</span>,
         <span class="dt">delete_layer =</span> T)
<span class="kw">st_write</span>(datos_<span class="dv">3</span>, 
         <span class="st">&quot;base_depurada.shp&quot;</span>, 
         <span class="dt">delete_layer =</span> T)
<span class="kw">st_write</span>(datos_<span class="dv">3</span>, 
         <span class="st">&quot;base_depurada.gpkg&quot;</span>, 
         <span class="dt">delete_layer =</span> T)</code></pre></div>
</div>
<div id="detección-de-tendencias-espaciales" class="section level2">
<h2><span class="header-section-number">5.3</span> Detección de tendencias espaciales</h2>
<p>Para evaluar las tendencia de la media del rendimiento con las coordenadas geográficas primero se incorpora al <code>data.frame</code> del objeto <code>sf</code> las coordenadas. De esta forma el objeto <code>datos_3</code> presenta la variable Rinde, su geometría y las coordenadas x e y.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_<span class="dv">3</span><span class="op">$</span>x &lt;-<span class="st"> </span><span class="kw">st_coordinates</span>(datos_<span class="dv">3</span>)[,<span class="dv">1</span>]
datos_<span class="dv">3</span><span class="op">$</span>y &lt;-<span class="st"> </span><span class="kw">st_coordinates</span>(datos_<span class="dv">3</span>)[,<span class="dv">2</span>]
<span class="kw">head</span>(datos_<span class="dv">3</span>)
<span class="co">#&gt; Simple feature collection with 6 features</span>
and <span class="dv">3</span> fields
<span class="co">#&gt; geometry type: POINT</span>
<span class="co">#&gt; dimension: XY</span>
<span class="co">#&gt; bbox: xmin: 312000 ymin: 5800000 xmax:</span>
<span class="dv">313000</span> ymax<span class="op">:</span><span class="st"> </span><span class="dv">5800000</span>
<span class="co">#&gt; epsg (SRID): 32721</span>
<span class="co">#&gt; proj4string: </span>
    <span class="op">+</span><span class="st"> </span>proj=utm 
    <span class="op">+</span><span class="st"> </span>zone=<span class="dv">21</span> 
    <span class="op">+</span><span class="st"> </span>south
<span class="op">+</span>datum=WGS84 <span class="op">+</span>units=m <span class="op">+</span>no_defs
<span class="co">#&gt; First 3 features:</span>
<span class="co">#&gt; Rinde geometry x y</span>
<span class="co">#&gt; 256 1,73 POINT (311987 5800811) 311987</span>
<span class="dv">5800811</span>
<span class="co">#&gt; 257 1,73 POINT (313167 5800905) 313167</span>
<span class="dv">5800905</span>
<span class="co">#&gt; 263 1,78 POINT (312511 5800721) 312511</span>
<span class="dv">5800721</span></code></pre></div>
<p>Para visualizar tendencias espaciales graficamos la variable en estudio en función de las coordenadas. Si se desea desplegar los gráficos para la coordenada x e y en una misma ventana gráfica, se puede particionar la ventana en una fila y dos columnas utilizando la siguiente función:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</code></pre></div>
<p>La función <code>plot()</code> permite realizar gráficos de dispersión. Además, puede adicionarse una línea de suavizado <em>lowess</em> con la función <code>lines()</code>. Esta última, realiza el ajuste sobre una ventana gráfica preexistente.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))

<span class="kw">with</span>(datos_<span class="dv">3</span>, {
  <span class="kw">plot</span>(Rinde <span class="op">~</span><span class="st"> </span>x)
  <span class="kw">lines</span>(<span class="kw">lowess</span>(Rinde <span class="op">~</span><span class="st"> </span>x), 
        <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">lwd =</span> <span class="dv">3</span>)

})
<span class="kw">with</span>(datos_<span class="dv">3</span>, {
  <span class="kw">plot</span>(Rinde <span class="op">~</span><span class="st"> </span>y)
  <span class="kw">lines</span>(<span class="kw">lowess</span>(Rinde <span class="op">~</span><span class="st"> </span>y), 
        <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">lwd =</span> <span class="dv">3</span>) 
})</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-44-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>Mediante un modelo lineal de regresión, puede ajustarse la tendencia entre la variable en estudio y las coordenadas. Si la tendencia lineal resulta significativa, debería descontarse trabajando con los residuos del modelo, que se obtienen con la función <code>residuals()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">regresion &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">formula =</span> Rinde <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span>y ,
                <span class="dt">data =</span> datos_<span class="dv">3</span>,
                <span class="dt">na.action =</span> na.omit)</code></pre></div>
<p>La siguiente línea despliega una tabla resumen del modelo:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(regresion)
<span class="co">#&gt;</span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = Rinde ~ 1 + x + y, data =</span>
datos_<span class="dv">3</span>, na.action =<span class="st"> </span>na.omit<span class="er">)</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Residuals:</span>
<span class="co">#&gt; Min 1Q Median 3Q Max</span>
<span class="co">#&gt; -3,165 -0,811 0,102 0,819 2,736</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; Estimate Std. Error t value Pr(&gt;|t|)</span>
<span class="co">#&gt; (Intercept) 1,84e+03 2,34e+02 7,85 4,6e-15</span>
<span class="op">**</span><span class="er">*</span>
<span class="co">#&gt; x -5,56e-04 4,10e-05 -13,54 &lt; 2e-16 ***</span>
<span class="co">#&gt; y -2,86e-04 4,10e-05 -6,98 3,2e-12 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes: 0 &#39;***&#39;</span>
<span class="st">    </span><span class="dv">0</span>,<span class="dv">001</span> <span class="st">&#39;**&#39;</span>
    <span class="dv">0</span>,<span class="dv">01</span> <span class="st">&#39;*&#39;</span>
<span class="dv">0</span>,<span class="dv">05</span> <span class="st">&#39;.&#39;</span>
    <span class="dv">0</span>,<span class="dv">1</span> <span class="st">&#39;</span>
<span class="st">    &#39;</span>
    <span class="dv">1</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Residual standard error: 1,07 on 9006</span>
degrees of freedom
<span class="co">#&gt; Multiple R-squared: 0,0348, Adjusted</span>
R<span class="op">-</span>squared<span class="op">:</span><span class="st"> </span><span class="dv">0</span>,<span class="dv">0346</span>
<span class="co">#&gt; F-statistic: 162 on 2 and 9006 DF, p-value:</span>
<span class="op">&lt;</span><span class="fl">2e-16</span></code></pre></div>
<p>En este caso, los gráficos exploratorios no marcan una tendencia marcada con las coordenadas. Aún, cuando los valores-p del modelo de regresión son significativos (p&lt;0,05), se decidió trabajar con la variable original debido a que el coeficiente de determinación del modelo acusa un ajuste pobre (0,035).</p>
</div>
<div id="cálculo-del-índice-de-moran" class="section level2">
<h2><span class="header-section-number">5.4</span> Cálculo del índice de Moran</h2>
<p>Para la conformación de la matriz de ponderadores espaciales se definieron los vecindarios de cada sitio mediante una red de conexión construida en base a la distancia euclídea. Se consideraron sitios vecinos a aquellos contiguos ubicados hasta 15 m de distancia. El procedimiento es similar al empleado para el cálculo de índice de Moran local. En este caso se agrega el argumento <code>zero.policy=T</code> dentro de la función <code>nb2listw()</code> y <code>moran.mc()</code>. Esto permite que se genera la matriz de pesos espaciales sin la restricción de que todos los puntos tengan al menos un dato vecino.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">vecindarios &lt;-<span class="st"> </span><span class="kw">dnearneigh</span>(datos_<span class="dv">3</span><span class="op">$</span>geom, 
                          <span class="dv">0</span>, <span class="dv">15</span>)
pesos_sp &lt;-<span class="st"> </span><span class="kw">nb2listw</span>(vecindarios, 
                     <span class="dt">style =</span> <span class="st">&quot;W&quot;</span>, 
                     <span class="dt">zero.policy =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>Para realizar el cálculo del Índice de Moran y determinar su significancia estadística mediante simulación Monte Carlo, se utiliza <code>moran.mc()</code>. Se debe especificar la variable en estudio, la lista con los pesos de las ponderaciones espaciales y el número de simulaciones.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">i.moran &lt;-
<span class="st">  </span><span class="kw">moran.mc</span>(
    datos_<span class="dv">3</span><span class="op">$</span>Rinde,
    <span class="dt">listw =</span> pesos_sp,
    <span class="dt">nsim =</span> <span class="dv">999</span>,
    <span class="dt">zero.policy =</span> T
  )
i.moran
<span class="co">#&gt;</span>
<span class="co">#&gt; Monte-Carlo simulation of Moran I</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; data: datos_3$Rinde</span>
<span class="co">#&gt; weights: pesos_sp</span>
<span class="co">#&gt; number of simulations + 1: 1000</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; statistic = 0,8, observed rank = 1000,</span>
p<span class="op">-</span>value =<span class="st"> </span><span class="dv">0</span>,<span class="dv">001</span>
<span class="co">#&gt; alternative hypothesis: greater</span></code></pre></div>
<p>Estos resultados permiten concluir que existe autocorrelación espacial positiva (0,78196) y que esta es estadísticamente significativa (p=0,001).</p>
</div>
<div id="análisis-basado-en-semivariogramas" class="section level2">
<h2><span class="header-section-number">5.5</span> Análisis basado en semivariogramas</h2>
<p>Las semivariogramas empíricos pueden obtenerse usando la función <code>variogram()</code> del paquete <code>gstat</code>. Esta tiene múltiples argumentos, entre ellos una fórmula, un objeto de datos espaciales y la distancia hasta la cual los pares de puntos son incluidos en la estimación de semivarianza (<code>cutoff</code>). Dado que el objeto a tratar (<code>datos_3</code>) es de clase <code>sf</code>, no es necesario realizar su transformación a un objeto del tipo espacial. Utilizando la función plot() se visualiza el semivariograma empírico ajustado.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">semiv_emp &lt;-<span class="st"> </span><span class="kw">variogram</span>(Rinde <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, 
                       datos_<span class="dv">3</span>, 
                       <span class="dt">cutoff =</span> <span class="dv">400</span>)
<span class="kw">head</span>(semiv_emp)
<span class="co">#&gt; np dist gamma dir.hor dir.ver id</span>
<span class="co">#&gt; 1 97403 18,0 0,412 0 0 var1</span>
<span class="co">#&gt; 2 281953 41,4 0,643 0 0 var1</span>
<span class="co">#&gt; [ reached &#39;max&#39;</span>
    <span class="op">/</span><span class="st"> </span><span class="kw">getOption</span>(<span class="st">&quot;max.print&quot;</span>) <span class="op">--</span>
omitted <span class="dv">4</span> rows ]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(semiv_emp,
     <span class="dt">main =</span> <span class="st">&quot;Rendimiento (t/ha)&quot;</span>,
     <span class="dt">xlab =</span> <span class="st">&quot;Distancia&quot;</span>,
     <span class="dt">ylab =</span> <span class="st">&quot;Semivarianza&quot;</span>)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-50-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>En el caso anterior la fórmula utilizada (<code>Rinde~1</code>) asume que el proceso es estacionario. Si se requiere adicionar una tendencia sea reemplaza el caracter 1 por el nombre de la covariable. Por ejemplo, si existe una tendencia dada por las coordenadas la fórmula se escribe como <code>Rinde~x+y</code>. Es posible solo colocar una de las coordenadas o incluir también términos polinómicos para las mismas. También se pueden usar otras covariables distintas a las coordenadas.</p>
<p>Por defecto para el cálculo del semivariograma empírico la función <code>variogram()</code> utiliza el estimador de los momentos de Matheron. Para emplear el estimador robusto de Cressie-Hawkins se adiciona en la función el argumento <code>cresice=TRUE</code>. Por defecto la función emplea para el cálculo del semivariograma un tercio de la diagonal del “cuadro” que contiene las observaciones. Con el argumento <code>cutoff</code> se puede cambiar esta distancia. El argumento <code>width</code> permite cambiar el ancho de los intervalos de distancia en los que se agrupan los pares de puntos de datos para las estimaciones de semivarianza. Por defecto se calcula como <code>cutoff/15</code>. El argumento alpha permite el cálculo de los semivariogramas en distintas direcciones en el plano (x, y), tomando valores en grados positivos en sentido horario desde y (Norte). Para <code>alpha = 0</code> la dirección es Norte y para <code>alpha = 90</code> la dirección es Este. Esto es útil para evaluar la presencia de anisotropía. Usualmente se suelen calcular los semivariogramas direccionales para <span class="math inline">\(45^\circ\)</span>, <span class="math inline">\(90^\circ\)</span>, <span class="math inline">\(135^\circ\)</span> y <span class="math inline">\(180^\circ\)</span>. Otras opciones pueden encontrarse mediante la función <code>help()</code>.</p>
<p>A continuación se ajusta un modelo de semivariograma teórico sobre el semivariograma empírico usando las funciones <code>fit.variogram()</code> y<code>vgm()</code>. Esta última ajusta el modelo teórico, sus argumentos indican el tipo de modelo a ajustar y los parámetros de ajuste (<em>partial sill</em>, rango y efecto <em>nugget</em>). Estos parámetros iniciales son de referencia y pueden obtenerse a partir del semivariograma empírico. Cambiar los parámetros modifica la suma de cuadrados del error (SCE).</p>
<p>Se ajusta un modelo esférico, con valores 0,6, 200 y 0,2 como parámetros iniciales para estimar el <em>sill</em> parcial, rango y <em>nugget</em>, respectivamente. La salida del software R muestra los parámetros del semivariograma teórico ajustado: <em>nugget</em> (<span class="math inline">\(C_0=0.31\)</span>), sill parcial (<span class="math inline">\(C=0.72\)</span>) y rango (154 m). Nota: bajo la columna <em>psill</em>, para la fila Nug, se debe leer el valor <span class="math inline">\(C_0\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mod_esf &lt;-<span class="st"> </span><span class="kw">fit.variogram</span>(
  semiv_emp,
  <span class="kw">vgm</span>(<span class="fl">0.6</span>, <span class="st">&quot;Sph&quot;</span>, <span class="dv">200</span>, <span class="fl">0.2</span>))
mod_esf
<span class="co">#&gt;   model psill range</span>
<span class="co">#&gt; 1   Nug 0,309     0</span>
<span class="co">#&gt; 2   Sph 0,719   154</span></code></pre></div>
<p>El semivariograma empírico (puntos) y teórico ajustado(linea), para un modelo esférico, puede graficarse de la siguiente manera:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(semiv_emp,
     mod_esf,
     <span class="dt">main =</span> <span class="st">&quot;Rendimiento (t/ha)&quot;</span>,
     <span class="dt">xlab =</span> <span class="st">&quot;Distancia&quot;</span>,
     <span class="dt">ylab =</span> <span class="st">&quot;Semivarianza&quot;</span>)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-52-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>El modelo que mejor ajusta será el de menor SCE. La función <code>attr()</code> devuelve atributos de un objeto y puede usarse para consultar la SCE del modelo ajustado.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attr</span>(mod_esf, <span class="st">&#39;SSErr&#39;</span>)
<span class="co">#&gt; [1] 1,7</span></code></pre></div>
<p>Repitiendo el procedimiento para un modelo exponencial (especificado en la función <code>vgm()</code>) se obtiene un menor SCE indicando mejor ajuste. Abajo se presenta la salida del software R que contiene los parámetros del semivariograma teórico ajustado: nugget (<span class="math inline">\(C_0=0.21\)</span>), sill parcial (<span class="math inline">\(C=0.86\)</span>) y rango (64,88 m) o Rango Practico (<span class="math inline">\(Rp=64.88 m \times 3\)</span>). Nota: bajo la columna “psill”, para la fila Nugget, se debe leer el valor <span class="math inline">\(C_0\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mod_exp &lt;-<span class="st"> </span><span class="kw">fit.variogram</span>(
  semiv_emp, 
  <span class="kw">vgm</span>(<span class="fl">0.6</span>, <span class="st">&quot;Exp&quot;</span>, <span class="dv">200</span>, <span class="fl">0.2</span>))
mod_exp
<span class="co">#&gt;   model psill range</span>
<span class="co">#&gt; 1   Nug 0,212   0,0</span>
<span class="co">#&gt; 2   Exp 0,860  64,9</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attr</span>(mod_exp, <span class="st">&#39;SSErr&#39;</span>)
<span class="co">#&gt; [1] 0,377</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(semiv_emp,
     mod_exp,
     <span class="dt">main =</span> <span class="st">&quot;Rendimiento (t/ha)&quot;</span>,
     <span class="dt">xlab =</span> <span class="st">&quot;Distancia&quot;</span>,
     <span class="dt">ylab =</span> <span class="st">&quot;Semivarianza&quot;</span>)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-56-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>Las siguientes líneas permiten la visualización conjunta de los dos ajustes realizados.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">vgLine &lt;-<span class="st"> </span><span class="kw">rbind</span>(
  <span class="kw">cbind</span>(
    <span class="kw">variogramLine</span>(
      mod_exp, <span class="dt">maxdist =</span> <span class="kw">max</span>(semiv_emp<span class="op">$</span>dist)),
    <span class="dt">id =</span> <span class="st">&quot;Exponencial&quot;</span>),
  <span class="kw">cbind</span>(
    <span class="kw">variogramLine</span>(
      mod_esf, <span class="dt">maxdist =</span> <span class="kw">max</span>(semiv_emp<span class="op">$</span>dist)),
    <span class="dt">id =</span> <span class="st">&quot;Esférico&quot;</span>)
  )


<span class="kw">ggplot</span>(semiv_emp, <span class="kw">aes</span>(<span class="dt">x =</span> dist, <span class="dt">y =</span> gamma, 
                      <span class="dt">color =</span> id)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="dt">data =</span> vgLine) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(
    <span class="dt">title =</span> <span class="st">&quot;Semivariograma experimental</span>
<span class="st">    y teórico ajustado&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Distancia&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Semivarianza&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_color_discrete</span>(
    <span class="dt">name =</span> <span class="st">&quot;Modelo&quot;</span>,
    <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;Esférico&quot;</span>, 
               <span class="st">&quot;Exponencial&quot;</span>, 
               <span class="st">&quot;Experimental&quot;</span>))</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-57-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>Algunas alternativas para aplicar las funciones de ajuste de los semivariogramas teóricos incluyen opciones de ajuste automático donde el usuario sólo especifica los modelos a ajustar sin tener que dar valores iniciales de los parámetros del semivariograma. La función estima valores iniciales razonables y selecciona aquel modelo de mejor bondad de ajuste en función a la SCE. A continuación, se presenta este ejemplo ajustando los modelos exponencial y esférico. Como era de esperar, el modelo de mejor ajuste fue el esférico.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">modelos &lt;-<span class="st"> </span><span class="kw">fit.variogram</span>(semiv_emp, 
                         <span class="kw">vgm</span>(<span class="kw">c</span>(<span class="st">&quot;Exp&quot;</span>, <span class="st">&quot;Sph&quot;</span>)))
modelos
<span class="co">#&gt;   model psill range</span>
<span class="co">#&gt; 1   Nug 0,212   0,0</span>
<span class="co">#&gt; 2   Exp 0,860  64,9</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attr</span>(modelos, <span class="st">&#39;SSErr&#39;</span>)
<span class="co">#&gt; [1] 0,377</span></code></pre></div>
<p>Si bien, como se mostró en el análisis exploratorio de los datos no se evidencia una tendencia en la variable rendimiento con las coordenadas, en las siguientes líneas se ilustra cómo se realiza el ajuste del semivariograma empírico con tendencia dada por las coordenadas (x e y) y el posterior ajuste del modelo teórico. Los resultados muestran que no se observan diferencias importantes en los parámetros estimados del semivariograma teórico. En casos donde la tendencia es importante su efecto se puede reflejar en el ajuste del semivariograma empírico el cual suele mostrar un incremento de la semivarianza a medida que aumenta la distancia que no alcanza a estabilizarse dentro del dominio bajo estudio.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">semiv_emp_t &lt;-<span class="st"> </span><span class="kw">variogram</span>(Rinde <span class="op">~</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span>y, 
                         datos_<span class="dv">3</span>, <span class="dt">cutoff =</span> <span class="dv">400</span>)
modelos_t &lt;-<span class="st"> </span><span class="kw">fit.variogram</span>(semiv_emp_t, 
                           <span class="kw">vgm</span>(<span class="kw">c</span>(<span class="st">&quot;Exp&quot;</span>, <span class="st">&quot;Sph&quot;</span>)))
modelos_t
<span class="co">#&gt;   model psill range</span>
<span class="co">#&gt; 1   Nug 0,208   0,0</span>
<span class="co">#&gt; 2   Exp 0,859  63,8</span>
<span class="kw">attr</span>(modelos_t, <span class="st">&#39;SSErr&#39;</span>)
<span class="co">#&gt; [1] 0,345</span>
<span class="kw">plot</span>(semiv_emp_t , modelos_t)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-60-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<div id="mapeo-de-la-variabilidad-espacial" class="section level3">
<h3><span class="header-section-number">5.5.1</span> Mapeo de la variabilidad espacial</h3>
<p>Para el mapeo de la variabilidad espacial se confeccionará una grilla de predicción donde se realiza el kriging. Las dimensiones de la grilla se establecerá mediante un polígono de los límites del lote. El archivo <strong>limites.txt</strong> contiene los puntos georreferenciados de cada arista del polígono.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">limites &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;datos/limites.txt&quot;</span>, 
                      <span class="dt">header =</span> <span class="ot">TRUE</span>)
<span class="kw">head</span>(limites)
<span class="co">#&gt;        x       y</span>
<span class="co">#&gt; 1 311842 5800614</span>
<span class="co">#&gt; 2 311950 5800728</span>
<span class="co">#&gt; 3 311998 5800788</span>
<span class="co">#&gt; 4 312006 5800835</span>
<span class="co">#&gt; 5 312566 5801431</span>
<span class="co">#&gt; 6 312590 5801435</span></code></pre></div>
<p>La función <code>pred_grid()</code> del paquete <code>geoR</code> genera una grilla regular de puntos de 10 metros de distancia entre estos. La función <code>polygrid()</code> recorta el polígono en la grilla siguiendo los límites del lote. Posteriormente se definen los nombres de las coordenadas y se transforma la clase del objeto a <code>sf</code> asignando el sistema de coordenadas.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">grid &lt;-<span class="st"> </span><span class="kw">pred_grid</span>(limites, <span class="dt">by =</span> <span class="dv">10</span>)
grid &lt;-<span class="st"> </span><span class="kw">polygrid</span>(grid, <span class="dt">bor =</span> limites)

<span class="kw">names</span>(grid) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)
grid &lt;-<span class="st"> </span><span class="kw">st_as_sf</span>(grid, <span class="dt">coords =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>),
                 <span class="dt">crs =</span> <span class="dv">32721</span>)
<span class="kw">plot</span>(grid)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-62-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>La función <code>krige()</code> del paquete <code>gstat</code> realiza interpolación kriging y simulaciones condicionales mediante diferentes métodos de predicción. En este caso, se presenta la interpolación por kriging ordinario con el modelo de semivariograma exponencial estimado con geoestadística clásica. Los argumentos de esta función incluyen, la fórmula en la cual se especifica que el proceso es estacionario (<code>Rinde~1</code>), la base de datos (<code>datos_3</code>), el objeto sobre el cual se hará la predicción (<code>grid</code>) y la información del modelo del modelo de semivariograma teórico ajustado (<code>model</code>) La información de este último se encuentra dentro del objeto <code>modelos</code>. Los argumentos <code>nmin</code> y <code>nmax</code> permiten realizar el proceso de interpolación en un contexto local, con un número mínimo y máximo de vecinos de cada punto a predecir de 7 y 25, respectivamente. En caso de omitir estos últimos argumentos la interpolación se realiza en un contexto global.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">kriging_o &lt;-
<span class="st">  </span><span class="kw">krige</span>(
    Rinde <span class="op">~</span><span class="st"> </span><span class="dv">1</span>,
    datos_<span class="dv">3</span>,
    <span class="kw">st_as_sf</span>(grid),
    <span class="dt">nmin =</span> <span class="dv">7</span>,
    <span class="dt">nmax =</span> <span class="dv">25</span>,
    <span class="dt">model =</span> modelos
  ) 
<span class="co">#&gt; [using ordinary kriging]</span></code></pre></div>
<p>A continuación, se realiza la visualización de la predicción y su varianza.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">predK_otm &lt;-<span class="st"> </span><span class="kw">tm_shape</span>(kriging_o) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="st">&quot;var1.pred&quot;</span>, <span class="dt">style =</span> <span class="st">&quot;cont&quot;</span>,
          <span class="dt">title =</span> <span class="st">&quot;Predicción&quot;)</span>
<span class="st">varK_otm &lt;-  tm_shape(kriging_o) +</span>
<span class="st">  tm_dots(&quot;</span>var1.var<span class="st">&quot;, style = &quot;</span>cont<span class="st">&quot;,</span>
<span class="st">          title = &quot;</span>Varianza<span class="st">&quot;)</span>

<span class="st">tmap_arrange(predK_otm, varK_otm)</span></code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-64-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>La siguiente línea de comando permite realizar la predicción kriging en bloques en un contexto local para lo cual solo se adiciona en la función <code>krige()</code> el argumento <code>block</code>. En este ejemplo se definió la dimensión del bloque de <span class="math inline">\(40 \times 40\)</span> m. Posteriormente se realiza la visualización de forma similar al caso anterior.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">kriging_b &lt;-
<span class="st">  </span><span class="kw">krige</span>(
    Rinde <span class="op">~</span><span class="st"> </span><span class="dv">1</span>,
    datos_<span class="dv">3</span>,
    grid ,
    <span class="dt">nmin =</span> <span class="dv">7</span>,
    <span class="dt">nmax =</span> <span class="dv">25</span>,
    <span class="dt">model =</span> modelos,
    <span class="dt">block =</span> <span class="kw">c</span>(<span class="dv">40</span>, <span class="dv">40</span>)
  )
<span class="co">#&gt; [using ordinary kriging]</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
predK_btm &lt;-<span class="st"> </span><span class="kw">tm_shape</span>(kriging_b) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="st">&quot;var1.pred&quot;</span>, <span class="dt">style =</span> <span class="st">&quot;cont&quot;</span>,
          <span class="dt">title =</span> <span class="st">&quot;Predicción Bloque&quot;</span>)
varK_btm &lt;-<span class="st">  </span><span class="kw">tm_shape</span>(kriging_b) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="st">&quot;var1.var&quot;</span>, <span class="dt">style =</span> <span class="st">&quot;cont&quot;</span>,
          <span class="dt">title =</span> <span class="st">&quot;Varianza Bloque&quot;</span>)

<span class="kw">tmap_arrange</span>(predK_btm, varK_btm)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-66-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>Las siguientes líneas de código muestran cómo obtener un <code>data.frame</code> conteniendo las predicciones realizadas sobre la grilla. En primer lugar, se extraen las coordenadas del objeto <code>kriging_b</code> y luego se transforma la clase del objeto a <code>data.frame</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">kriging_b<span class="op">$</span>x &lt;-<span class="st"> </span><span class="kw">st_coordinates</span>(kriging_b)[, <span class="dv">1</span>]
kriging_b<span class="op">$</span>y &lt;-<span class="st"> </span><span class="kw">st_coordinates</span>(kriging_b)[, <span class="dv">2</span>]
predRinde &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">data.frame</span>(kriging_b)[, <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, 
                            <span class="st">&quot;var1.pred&quot;</span>)]
<span class="kw">names</span>(predRinde)[<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;Tg&quot;</span>)</code></pre></div>
<p>En el caso que exista una tendencia dada por las coordenadas, se utiliza kriging universal como método de interpolación espacial. Los comandos son similares a los anteriores, sólo debe cambiarse la fórmula. Por ejemplo, para una tendencia de primer grado en las coordenadas espaciales se escribiría <code>Rinde~x+y</code>. El modelo de semivariograma que se utiliza debe haberse ajustando contemplado el mismo tipo de tendencia. En situaciones donde otras covariables explican la tendencia en la media, éstas deben especificarse en la fórmula. Para poder hacer la interpolación es necesario que los valores de las covariables también estén disponibles en la grilla de predicción. En este último caso la interpolación se denomina kriging con deriva externa.</p>
<p>La interpolación también puede hacerse utilizando los parámetros <em>partial sill</em>, rango y <em>nugget</em> del semivariograma estimado con REML. Para el ajuste de un MLM con errores correlacionados espacialmente vía REML, la base de datos no debe ser muy grande. Para poder realizar el ajuste de un MLM en el conjunto de datos de ilustración, se tomó una muestra aleatoria de n=500 sobre la base de datos original de n=9009, usando la función <code>sample()</code>. Las siguientes líneas de código muestran el ajuste del semivariograma y obtención de los parámetros del mismo usando la función <code>gls()</code> del paquete <code>nlme</code>. Se realiza el ajuste de dos modelos lineales, el primero sin correlación espacial (<code>null_model</code>) y el segundo con una estructura de correlación espacial del tipo exponencial (<code>esp_model</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">7</span>)
datos_<span class="dv">4</span> &lt;-<span class="st"> </span>datos_<span class="dv">3</span>[
  <span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(datos_<span class="dv">3</span>), 
         <span class="dv">500</span>, <span class="dt">replace =</span> <span class="ot">FALSE</span>), ]
null_model &lt;-
<span class="st">  </span><span class="kw">gls</span>(Rinde <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, datos_<span class="dv">4</span>, 
      <span class="dt">method =</span> <span class="st">&quot;REML&quot;</span>, 
      <span class="dt">na.action =</span> na.omit)

esp_model &lt;-<span class="st"> </span><span class="kw">gls</span>(
  Rinde <span class="op">~</span><span class="st"> </span><span class="dv">1</span>,
  <span class="dt">data =</span> datos_<span class="dv">4</span>,
  <span class="dt">correlation =</span> <span class="kw">corExp</span>(
    <span class="dt">form =</span>  <span class="op">~</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span>y,
    <span class="dt">metric =</span> <span class="st">&quot;euclidean&quot;</span>,
    <span class="dt">nugget =</span> T
  ),
  <span class="dt">method =</span> <span class="st">&quot;REML&quot;</span>,
  <span class="dt">na.action =</span> na.omit
)</code></pre></div>
<p>A continuación, se realiza la comparación de ambos modelos mediante la prueba del cociente de verosimilitud. Los resultados muestran que hay diferencias significativas (p&lt;0.005) entre ambos modelos, con lo cual se elige el modelo espacial. Los valores de AIC y BIC también mostraban un mejor ajuste de este último.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">anova</span>(null_model, esp_model)
<span class="co">#&gt; Model df AIC BIC logLik Test L.Ratio p-value</span>
<span class="co">#&gt; null_model 1 2 1526 1535 -761</span>
<span class="co">#&gt; esp_model 2 4 1230 1247 -611 1 vs 2 300</span>
<span class="op">&lt;</span>.<span class="dv">0001</span></code></pre></div>
<p>Con el modelo ajustado se obtienen los parámetros del semivariograma y se construye el objeto <code>m</code> que contendrá estos para su posterior interpolación vía kriging.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(esp_model)
<span class="co">#&gt; Generalized least squares fit by REML</span>
<span class="co">#&gt; Model: Rinde ~ 1</span>
<span class="co">#&gt; Data: datos_4</span>
<span class="co">#&gt; AIC BIC logLik</span>
<span class="co">#&gt; 1230 1247 -611</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Correlation Structure: Exponential spatial</span>
correlation
<span class="co">#&gt; Formula: ~x + y</span>
<span class="co">#&gt; Parameter estimate(s):</span>
<span class="co">#&gt; range nugget</span>
<span class="co">#&gt; 102,547 0,134</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; Value Std.Error t-value p-value</span>
<span class="co">#&gt; (Intercept) 4,22 0,234 18 0</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Standardized residuals:</span>
<span class="co">#&gt; Min Q1 Med Q3 Max</span>
<span class="co">#&gt; -1,848 -0,371 0,378 1,097 2,634</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Residual standard error: 1,18</span>
<span class="co">#&gt; Degrees of freedom: 500 total; 499 residual</span>
esp_model<span class="op">$</span>sigma
<span class="co">#&gt; [1] 1,18</span>
nugget &lt;-<span class="st"> </span><span class="fl">0.1344285</span> <span class="op">*</span><span class="st"> </span>esp_model<span class="op">$</span>sigma <span class="op">^</span><span class="st"> </span><span class="dv">2</span>
psill &lt;-<span class="st"> </span>esp_model<span class="op">$</span>sigma <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">-</span><span class="st"> </span>nugget
range &lt;-<span class="st"> </span><span class="fl">102.5470883</span>

m &lt;-<span class="st"> </span><span class="kw">vgm</span>(psill, <span class="st">&quot;Exp&quot;</span>, range, nugget)
kriging_mlm &lt;-
<span class="st">  </span><span class="kw">krige</span>(
    Rinde <span class="op">~</span><span class="st"> </span><span class="dv">1</span>,
    datos_<span class="dv">4</span>,
    grid ,
    <span class="dt">nmin =</span> <span class="dv">7</span>,
    <span class="dt">nmax =</span> <span class="dv">25</span>,
    <span class="dt">model =</span> m
  )
<span class="co">#&gt; [using ordinary kriging]</span></code></pre></div>
<p>El mismo ajuste de semivariograma puede realizarse utilizando la función <code>likfit()</code> del paquete <code>geoR</code>. En este caso es necesario generar un objeto del tipo <code>geodata</code>. La función de ajuste solicita valores iniciales de <em>sill</em> parcial y rango y modelo teórico (para esta aplicación se usa el exponencial). En el caso del efecto <em>nugget</em> el mismo es estimado por defecto. Es posible también incorporar tendencias utilizando el argumento <code>trend</code>. Los resultados del modelo muestran valores estimados de los parámetros similares a los obtenidos con la función <code>gls()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datos_geor &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(datos_<span class="dv">4</span>)
datos_geor &lt;-
<span class="st">  </span><span class="kw">as.geodata</span>(datos_geor,
             <span class="dt">coords.col =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>),
             <span class="dt">data.col =</span> <span class="st">&quot;Rinde&quot;</span>)

mlm_geor &lt;-
<span class="st">  </span><span class="kw">likfit</span>(
    datos_geor,
    <span class="dt">ini =</span> <span class="kw">c</span>(<span class="fl">0.7</span>, <span class="dv">90</span>),
    <span class="dt">cov.model =</span> <span class="st">&quot;exponential&quot;</span>,
    <span class="dt">lik.method =</span> <span class="st">&quot;REML&quot;</span>,
    <span class="dt">messages =</span> <span class="ot">FALSE</span>
  )
<span class="kw">summary</span>(mlm_geor)
<span class="co">#&gt; Summary of the parameter estimation</span>
<span class="co">#&gt; -----------------------------------</span>
<span class="co">#&gt; Estimation method: restricted maximum</span>
likelihood
<span class="co">#&gt;</span>
<span class="co">#&gt; Parameters of the mean component (trend):</span>
<span class="co">#&gt; beta</span>
<span class="co">#&gt; 4,22</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Parameters of the spatial component:</span>
<span class="co">#&gt; correlation function: exponential</span>
<span class="co">#&gt; (estimated) variance parameter sigmasq</span>
(partial sill) =<span class="st"> </span><span class="dv">1</span>,<span class="dv">2</span>
<span class="co">#&gt; (estimated) cor. fct. parameter phi (range</span>
parameter<span class="er">)</span> =<span class="st"> </span><span class="dv">103</span>
<span class="co">#&gt; anisotropy parameters:</span>
<span class="co">#&gt; (fixed) anisotropy angle = 0 ( 0 degrees )</span>
<span class="co">#&gt; (fixed) anisotropy ratio = 1</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Parameter of the error component:</span>
<span class="co">#&gt; (estimated) nugget = 0,186</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Transformation parameter:</span>
<span class="co">#&gt; (fixed) Box-Cox parameter = 1 (no</span>
transformation<span class="er">)</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Practical Range with cor=0.05 for asymptotic</span>
range<span class="op">:</span><span class="st"> </span><span class="dv">307</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Maximised Likelihood:</span>
<span class="co">#&gt; log.L n.params AIC BIC</span>
<span class="co">#&gt; &quot;-608&quot; &quot;4&quot; &quot;1224&quot; &quot;1241&quot;</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; non spatial model:</span>
<span class="co">#&gt; log.L n.params AIC BIC</span>
<span class="co">#&gt; &quot;-758&quot; &quot;2&quot; &quot;1520&quot; &quot;1528&quot;</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; likfit(geodata = datos_geor, ini.cov.pars =</span>
<span class="kw">c</span>(<span class="fl">0.7</span>, <span class="dv">90</span>), cov.model =<span class="st"> &quot;exponential&quot;</span>,
<span class="co">#&gt; lik.method = &quot;REML&quot;, messages = FALSE)</span></code></pre></div>
</div>
<div id="validación-cruzada-1" class="section level3">
<h3><span class="header-section-number">5.5.2</span> Validación cruzada</h3>
<p>A continuación, se ilustra el proceso de validación cruzada <em>k-fold</em>. En este caso la función utilizada es <code>krige.cv()</code> del paquete <code>gstat</code>. Aquí como en el ajuste del semivariogram empírico y la interpolación, se tienen los argumentos fórmula (<code>Rinde~1</code>, lo cual especifica que es un proceso estacionario), la base de datos (<code>datos_3</code>) y el modelo de semivariograma teórico ajustado (<code>modelos</code>). Aquí también se realiza la validación usando kriging en un contexto local por lo que se colocan los argumentos <code>nmin</code> y <code>nmax</code>. El argumento <code>nfold</code> determina el número de grupos (k) en los que se divide la base de datos para realizar la validación cruzada <em>k-fold</em>. Para obtener repetibilidad en los resultados se sugiere fijar la semilla mediante la función <code>set.seed()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">17</span>)
valcru &lt;-
<span class="st">  </span><span class="kw">krige.cv</span>(
    Rinde <span class="op">~</span><span class="st"> </span><span class="dv">1</span>,
    datos_<span class="dv">3</span>,
    modelos,
    <span class="dt">nfold =</span> <span class="dv">10</span>,
    <span class="dt">nmin =</span> <span class="dv">7</span>,
    <span class="dt">nmax =</span> <span class="dv">25</span>
  )</code></pre></div>
<p>Realizada la validación es posible calcular estadísticos resumen como el error medio (ME), error cuadrático medio (MSE), media del cociente de la desviación cuadrática (<em>mean squared deviation ratio</em>, MSDR), raíz del error cuadrático medio (RMSE), la RMSE relativa a la media de los observados (RMSE_rel) y la correlación lineal entre los observados vs. Predichos. Un gráfico de estos últimos se muestra al final.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ME &lt;-<span class="st"> </span><span class="kw">mean</span>(valcru<span class="op">$</span>residual)
MSE &lt;-<span class="st"> </span><span class="kw">mean</span>(valcru<span class="op">$</span>residual <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)
MSDR &lt;-<span class="st"> </span><span class="kw">mean</span>(valcru<span class="op">$</span>zscore <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)
RMSE &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">mean</span>(valcru<span class="op">$</span>residual <span class="op">^</span><span class="st"> </span><span class="dv">2</span>))
RMSE_rel &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">sqrt</span>(<span class="kw">mean</span>(valcru<span class="op">$</span>residual <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)) <span class="op">/</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mean</span>(valcru<span class="op">$</span>observed) <span class="op">*</span><span class="st"> </span><span class="dv">100</span>
r &lt;-<span class="st"> </span><span class="kw">cor</span>(valcru<span class="op">$</span>observed, 
         valcru<span class="op">$</span>observed <span class="op">-</span><span class="st"> </span>valcru<span class="op">$</span>residual)

tabla &lt;-<span class="st"> </span><span class="kw">data.frame</span>(ME, MSE, RMSE, 
                    RMSE_rel, MSDR, r)
tabla
<span class="co">#&gt;         ME   MSE  RMSE RMSE_rel  MSDR     r</span>
<span class="co">#&gt; 1 -0,00018 0,228 0,478     10,3 0,665 0,899</span>
<span class="kw">plot</span>(
  valcru<span class="op">$</span>observed,
  valcru<span class="op">$</span>observed <span class="op">-</span><span class="st"> </span>valcru<span class="op">$</span>residual,
  <span class="dt">xlab =</span> <span class="st">&quot;Observados&quot;</span>,
  <span class="dt">ylab =</span> <span class="st">&quot;Predichos&quot;</span>
)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-73-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="caracterización-de-variabilidad-espacial-con-múltiples-capas-de-datos-1" class="section level2">
<h2><span class="header-section-number">5.6</span> Caracterización de variabilidad espacial con múltiples capas de datos</h2>
<div id="análisis-de-componentes-principales-1" class="section level3">
<h3><span class="header-section-number">5.6.1</span> Análisis de componentes principales</h3>
<p>Para implementar el análisis multivariado es necesario contar con información de cada variable en los mismos sitios georreferenciados. En esta sección se usa la base de datos <strong>Pred2.txt</strong> que contiene mediciones de conductividad eléctrica aparente en dos profundidades 0-30 cm (CE30) y 0-90 cm (CE90), elevación (Elev), profundidad de suelo (Pe) y rendimiento de trigo (Tg). Para generar esta base debido a las diferentes resoluciones espaciales de las variables medidas, se calculó una zona buffer de 15 m de radio para la variable Pe y sobre cada punto buffer se calculó la mediana de las restantes variables. La matriz de datos resultante quedó conformada por n=482 sitios (filas) y p=7 variables (columnas).</p>
<p>Para realizar el Análisis de Componentes Principales espacial (MULTISPATI-PCA) se utiliza los paquetes <code>ade4</code> y <code>adespatial</code>. Primero se necesita calcular la matriz de ponderación espacial en forma similar a la realizada para el cálculo del índice de Moran. Luego, se realiza un Análisis de Componentes Principales (PCA) clásico y posteriormente sobre las componentes generadas por PCA, se aplica el MULTISPATI-PCA.</p>
<p>Carga de base de datos multivariada.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pred &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;datos/Pred2.txt&quot;</span>, 
                   <span class="dt">header =</span> <span class="ot">TRUE</span>)
<span class="kw">head</span>(pred)
<span class="co">#&gt; x y Pe Elev CE30 CE90 Tg</span>
<span class="co">#&gt; 1 312283 5800205 80 161 21,8 30,6 4,19</span>
<span class="co">#&gt; 2 312257 5800229 40 161 30,3 17,9 4,00</span>
<span class="co">#&gt; [ reached &#39;max&#39;</span>
    <span class="op">/</span><span class="st"> </span><span class="kw">getOption</span>(<span class="st">&quot;max.print&quot;</span>) <span class="op">--</span>
omitted <span class="dv">4</span> rows ]</code></pre></div>
<p>La función <code>dudi.pca()</code> del paquete <code>ade4</code>, permite realizar un PCA sobre objetos de clase <code>data.frame</code>. Sus argumentos indican, las variables con las que se realizará el PCA, un valor lógico (<code>TRUE</code> o <code>FALSE</code>) indicando si debe o no centrarse por la media (<code>center</code>) y normalizarse (<code>scale</code>), un valor lógico para la realización o no del gráfico (<code>scannf</code>) y la cantidad de ejes guardados (<code>nf</code>), que coincide con la cantidad de variables utilizadas en el análisis.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pca &lt;-
<span class="st">  </span><span class="kw">dudi.pca</span>(
    pred[, <span class="dv">3</span><span class="op">:</span><span class="dv">7</span>],
    <span class="dt">center =</span> <span class="ot">TRUE</span>,
    <span class="dt">scale =</span> <span class="ot">TRUE</span>,
    <span class="dt">scannf =</span> <span class="ot">FALSE</span>,
    <span class="dt">nf =</span> <span class="dv">5</span>
  )</code></pre></div>
<p>Para transformar un PCA en un PCA espacial (MULTISPATI-PCA) se calcula la red de vecindarios y la matriz de ponderación espacial. La distancia máxima para definir los sitios vecinos de cada dato fue de 45 m. Además, se adiciona el argumento <code>zero.policy=T</code> para poder generar la matriz de pesos espaciales contemplando que algunos puntos no tengan datos vecinos. La función <code>multispati()</code> permite realizar el MUlTISPATI-PCA. Para ello es necesario colocar en la función el objeto que surge de realizar el ACP (pca) y la matriz de pesos espaciales (<code>pesos_sp</code>). El argumento <code>nfposi</code> hace referencia al número de ejes con autocorrelación positiva que es retenido en el análisis. También pueden guardarse ejes con autocorrelación negativa mediante el argumento <code>nfnega</code>. En general los ejes con autocorrelación negativa son aquellos de menor contribución a la variabilidad total.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cord &lt;-<span class="st"> </span><span class="kw">coordinates</span>(pred[, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>])
vecindarios &lt;-<span class="st"> </span><span class="kw">dnearneigh</span>(cord, <span class="dv">0</span>, <span class="dv">45</span>)
pesos_sp &lt;-<span class="st"> </span><span class="kw">nb2listw</span>(vecindarios, 
                     <span class="dt">style =</span> <span class="st">&quot;W&quot;</span>, 
                     <span class="dt">zero.policy =</span> T)

pca_esp &lt;-
<span class="st">  </span>adespatial<span class="op">::</span><span class="kw">multispati</span>(pca, pesos_sp, 
                         <span class="dt">scannf =</span> F, <span class="dt">nfposi =</span> <span class="dv">5</span>)</code></pre></div>
<p>Para realizar un gráfico que muestre las correlaciones entre las variables se puede usar la función <code>s.arrow()</code>. En este gráfico de traza un vector para cada variable en el espacio definido por las componentes principales que se seleccionen. En este caso de estudio, la función utiliza la primera componente para graficar el eje horizontal y la segunda componente para el eje vertical. Para adicionar un gráfico de barras con los autovalores puede usarse el argumento <code>add.scatter.eig()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">s.arrow</span>(pca_esp<span class="op">$</span>c1,
        <span class="dt">xax =</span> <span class="dv">1</span>,
        <span class="dt">yax =</span> <span class="dv">2</span>,
        <span class="dt">clabel =</span> <span class="dv">1</span>)
<span class="kw">add.scatter.eig</span>(
  pca_esp<span class="op">$</span>eig,
  <span class="dt">xax =</span> <span class="dv">1</span>,
  <span class="dt">yax =</span> <span class="dv">2</span>,
  <span class="dt">posi =</span> <span class="st">&quot;bottomright&quot;</span>,
  <span class="dt">ratio =</span> <span class="fl">0.2</span>
)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-77-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>El gráfico obtenido del MULTISPATI-PCA muestra que las variables Elev y Pe son las más importantes en la explicación de la variabilidad espacial a nivel del primer eje (sPC1, eje horizontal). Mientras que la CE30 y Tg presentan mayor importancia en la SPC2. Además, se observa una correlación positiva entre CE30 y CE90, y negativa entre estas dos y la Pe. También la Elev y Tg se correlacionan en forma negativa. El gráfico de autovalores (barras) sugiere dos estructuras principales a nivel de sPC1 y sPC2, siempre la sPC1 explica la mayor parte de la variabilidad de los datos seguida por sPC2, sPC3, y así sucesivamente.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(pca_esp)
<span class="co">#&gt;</span>
<span class="co">#&gt; Multivariate Spatial Analysis</span>
<span class="co">#&gt; Call: adespatial::multispati(dudi = pca,</span>
listw =<span class="st"> </span>pesos_sp, scannf =<span class="st"> </span>F,
<span class="co">#&gt; nfposi = 5)</span>
<span class="co">#&gt;</span>
<span class="co">#&gt; Scores from the initial duality diagram:</span>
<span class="co">#&gt; var cum ratio moran</span>
<span class="co">#&gt; RS1 1,936 1,94 0,387 0,676</span>
<span class="co">#&gt; RS2 1,078 3,01 0,603 0,405</span>
<span class="co">#&gt; RS3 0,878 3,89 0,778 0,250</span>
<span class="co">#&gt; RS4 0,628 4,52 0,904 0,552</span>
<span class="co">#&gt; [ reached &#39;max&#39;</span>
    <span class="op">/</span><span class="st"> </span><span class="kw">getOption</span>(<span class="st">&quot;max.print&quot;</span>) <span class="op">--</span>
omitted <span class="dv">1</span> rows ]
<span class="co">#&gt;</span>
<span class="co">#&gt; Multispati eigenvalues decomposition:</span>
<span class="co">#&gt; eig var moran</span>
<span class="co">#&gt; CS1 1,4254 1,808 0,7884</span>
<span class="co">#&gt; CS2 0,4684 1,095 0,4277</span>
<span class="co">#&gt; CS3 0,3712 0,748 0,4963</span>
<span class="co">#&gt; CS4 0,0790 0,689 0,1147</span>
<span class="co">#&gt; CS5 0,0484 0,660 0,0734</span></code></pre></div>
<p>Como se establece en la literatura, MULTISPATI-PCA maximiza el producto entre la varianza espacial y la autocorrelación mientras que PCA maximiza la varianza total. Los resultados muestran que con MULTISPATIPCA se explica una menor proporción de la varianza acumulada en el primer eje, respecto de PCA (1,81 vs. 1,94). Las dos primeras CP del PCA explican 60% de la variabilidad total mientras que la CS1 y CS2 del MULTISPATI el 58%. No obstante, los valores del índice de Moran calculados para las tres primeras CPs sugieren que la estimación de autocorrelación aumentó cuando se usó MULTISPATIPCA respecto de la contenida en las CPs del PCA (0,79 vs. 0,68 para el eje 1, 0,43 vs. 0,40 para el eje 2, 0,50 vs. 0,25 para el eje 3). Este resultado permitiría una visualización mejor de la variabilidad espacial. Por el contrario, a nivel de las CPs 4 y 5 este comportamiento fue inverso.</p>
</div>
<div id="análisis-de-conglomerados-1" class="section level3">
<h3><span class="header-section-number">5.6.2</span> Análisis de conglomerados</h3>
<p>Para implementar este análisis también es necesario contar con información de cada variable en los mismos sitios georreferenciados. Otra forma de lograr esto es interpolar cada una de ellas con la misma grilla de predicción. Es decir, que cada punto de la grilla tendrá un dato para cada variable predicha. Para el siguiente caso de estudio se realizó el procedimiento de interpolación con mediciones de conductividad eléctrica aparente en dos profundidades 0-30 cm (CE30) y 0-90 cm (CE90), elevación (Elev), profundidad de suelo (Pe) y rendimiento de trigo (Tg) (archivo <strong>Pred.txt</strong>). Para cada variable se realizó un análisis exploratorio y la predicción espacial para el re-escalado usando una grilla común a todas ellas de <span class="math inline">\(10 \times 10\)</span> m. Una vez que se realiza el re-escalado de cada variable, se tiene un objeto para cada variable con igual número de filas y columnas que pueden unirse en un único objeto usando la función <code>cbind()</code>. Para <code>predRinde</code> se extraen las 3 primeras columnas correspondiente a las coordenadas y valores predichos, mientras que para las restantes sólo se extraen los valores predichos de cada variable (columna 3) considerando que, si se utilizó la misma grilla de predicción, las coordenadas de cada <code>data.frame</code> deberían ser las mismas. Se recomienda mantener clara la nomenclatura de cada variable, teniendo en cuenta que el software es <em>case-sensitive</em> (sensible a mayúsculas y minúsculas). A tal efecto, se renombraron las columnas. A continuación, se muestras los códigos de R para hacer el procedimiento de concatenación, pero para la ejemplificación se carga y utiliza una base de datos que previamente fue concatenada.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pred &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;datos/Pred.txt&quot;</span>, 
                   <span class="dt">header =</span> T)</code></pre></div>
<p>Posteriormente, se implementará el análisis de clúster espacial KM-sPC <span class="citation">(Córdoba et al. <a href="#ref-Cordoba2013">2013</a>)</span>. Para ello primero se realiza un análisis de componentes principales espaciales (MULTISPATI-PCA) sobre las variables originales. Luego las variables sintéticas (componentes principales espaciales, sPC) son utilizadas como input del análisis de <em>cluster fuzzy k-means</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pca &lt;-
<span class="st">  </span><span class="kw">dudi.pca</span>(
    pred[, <span class="dv">3</span><span class="op">:</span><span class="dv">7</span>],
    <span class="dt">center =</span> <span class="ot">TRUE</span>,
    <span class="dt">scale =</span> <span class="ot">TRUE</span>,
    <span class="dt">scannf =</span> <span class="ot">FALSE</span>,
    <span class="dt">nf =</span> <span class="dv">5</span>
  )

cord &lt;-<span class="st"> </span><span class="kw">coordinates</span>(pred[, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>])
vecindarios &lt;-<span class="st"> </span><span class="kw">dnearneigh</span>(cord, <span class="dv">0</span>, <span class="dv">10</span>)
pesos_sp &lt;-<span class="st"> </span><span class="kw">nb2listw</span>(vecindarios, 
                     <span class="dt">style =</span> <span class="st">&quot;W&quot;</span>, 
                     <span class="dt">zero.policy =</span> T)

pca_esp &lt;-
<span class="st">  </span>adespatial<span class="op">::</span><span class="kw">multispati</span>(pca, pesos_sp, 
                         <span class="dt">scannf =</span> F, <span class="dt">nfposi =</span> <span class="dv">5</span>)</code></pre></div>
<p>La función <code>multispati()</code> almacena las sPC en la posición <code>li</code> dentro de los objetos creados. La siguiente sentencia crea un nuevo objeto con la unión de las columnas con las coordenadas y las sPC.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cs &lt;-<span class="st"> </span>pca_esp<span class="op">$</span>li[, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]
pred_am &lt;-<span class="st"> </span><span class="kw">cbind</span>(pred[, <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)], cs)
<span class="kw">head</span>(pred_am)
<span class="co">#&gt; x y CS1 CS2 CS3 CS4 CS5</span>
<span class="co">#&gt; 1 312433 5800234 1,92 0,543 -0,118 -0,321</span>
<span class="dv">0</span>,<span class="dv">0257</span>
<span class="co">#&gt; 2 312423 5800244 1,93 0,448 -0,215 -0,256</span>
<span class="dv">0</span>,<span class="dv">1732</span>
<span class="co">#&gt; [ reached &#39;max&#39;</span>
    <span class="op">/</span><span class="st"> </span><span class="kw">getOption</span>(<span class="st">&quot;max.print&quot;</span>) <span class="op">--</span>
omitted <span class="dv">4</span> rows ]</code></pre></div>
<p>Para realizar el análisis de <em>cluster fuzzy k-means</em> se utiliza la función <code>cmeans()</code> del paquete <code>e1071</code> <span class="citation">(Meyer et al. <a href="#ref-R-e1071">2019</a>)</span>. Para ello se necesita determinar las sPC que se utilizarán como <em>input</em>. En este caso se seleccionaron las columnas que corresponden a la sPC1, sPC2 y sPC3, de esta forma una gran cantidad de la variabilidad total es contemplada (<span class="math inline">\(\ge 70 \%\)</span>) en el análisis. En este ejemplo se utilizaron 2, 3 y 4 clústers. Otras opciones de configuración son el número de iteraciones=100; método=<code>cmeans</code> (opción para usar el algoritmo fuzzy) y exponente difuso <code>m=1.3</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">clases2 &lt;-<span class="st"> </span><span class="kw">cmeans</span>(pred_am[, <span class="dv">3</span><span class="op">:</span><span class="dv">5</span>], <span class="dv">2</span>, 
                  <span class="dv">100</span>, <span class="dt">method =</span> <span class="st">&quot;cmeans&quot;</span>, 
                  <span class="dt">m =</span> <span class="fl">1.3</span>)
clases3 &lt;-<span class="st"> </span><span class="kw">cmeans</span>(pred_am[, <span class="dv">3</span><span class="op">:</span><span class="dv">5</span>], <span class="dv">3</span>, 
                  <span class="dv">100</span>, <span class="dt">method =</span> <span class="st">&quot;cmeans&quot;</span>, 
                  <span class="dt">m =</span> <span class="fl">1.3</span>)
clases4 &lt;-<span class="st"> </span><span class="kw">cmeans</span>(pred_am[, <span class="dv">3</span><span class="op">:</span><span class="dv">5</span>], <span class="dv">4</span>, 
                  <span class="dv">100</span>, <span class="dt">method =</span> <span class="st">&quot;cmeans&quot;</span>, 
                  <span class="dt">m =</span> <span class="fl">1.3</span>)</code></pre></div>
<p>En el ejemplo de ilustración se debe seleccionar entre dos, tres y cuatro clases. Para ello se utilizaron los siguientes índices: Xie-Beni, coeficiente de partición, entropía de clasificación y Fukuyama-Sugeno. Estos índices serán calculados para 2, 3 y 4 clases o clúster, utilizando la función <code>fclustIndex()</code>. En todos los índices, excepto el coeficiente de partición, el número de clases óptimo se obtiene cuando los índices tienen el menor valor. Para hacer que la interpretación del coeficiente de partición sea igual a los otros índices, se utiliza el valor inverso del índice. Luego se confeccionó una tabla con los índices obtenidos.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">indices &lt;-<span class="st">  </span><span class="kw">c</span>(
  <span class="st">&quot;xie.beni&quot;</span>,
  <span class="st">&quot;fukuyama.sugeno&quot;</span>,
  <span class="st">&quot;partition.coefficient&quot;</span>,
  <span class="st">&quot;partition.entropy&quot;</span>,
  <span class="st">&quot;proportion.exponent&quot;</span>
)

ind_2clases &lt;-
<span class="st">  </span><span class="kw">fclustIndex</span>(clases2,
              pred_am[, <span class="dv">3</span><span class="op">:</span><span class="dv">5</span>],
              <span class="dt">index =</span> indices)

ind_3clases &lt;-
<span class="st">  </span><span class="kw">fclustIndex</span>(clases3,
              pred_am[, <span class="dv">3</span><span class="op">:</span><span class="dv">5</span>],
              <span class="dt">index =</span> indices)

ind_4clases &lt;-
<span class="st">  </span><span class="kw">fclustIndex</span>(clases4,
              pred_am[, <span class="dv">3</span><span class="op">:</span><span class="dv">5</span>],
              <span class="dt">index =</span> indices)

indices &lt;-<span class="st"> </span><span class="kw">cbind</span>(ind_2clases, 
                 ind_3clases, 
                 ind_4clases)
indices
<span class="co">#&gt;     ind_2clases ind_3clases ind_4clases</span>
<span class="co">#&gt; xb     4,83e-05    9,37e-05    1,09e-04</span>
<span class="co">#&gt; fs    -1,20e+04   -1,32e+04   -1,44e+04</span>
<span class="co">#&gt; pc     9,26e-01    8,63e-01    8,34e-01</span>
<span class="co">#&gt; pe     1,26e-01    2,43e-01    3,02e-01</span>
<span class="co">#&gt; pre         Inf         Inf         Inf</span></code></pre></div>
<p>En este ejemplo la mayoría de los índices, excepto Fukuyama-Sugeno, muestran que el número de clases a seleccionar es dos. Puede suceder que ninguno de los índices coincida con otro en el número óptimo de clases. Para facilitar la toma de decisiones se recomienda calcular un índice resumen para cada clasificación. Este nuevo índice puede ser la distancia Euclídea de los valores de los índices previamente normalizados por su valor máximo a través de las diferentes clasificaciones.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">XieBeniN &lt;-<span class="st"> </span>indices[<span class="dv">1</span>,] <span class="op">/</span><span class="st"> </span><span class="kw">max</span>(indices[<span class="dv">1</span>,])
FukSugN &lt;-<span class="st"> </span>indices[<span class="dv">2</span>,] <span class="op">/</span><span class="st"> </span><span class="kw">max</span>(indices[<span class="dv">2</span>,])
CoefPartN &lt;-<span class="st"> </span>indices[<span class="dv">3</span>,] <span class="op">/</span><span class="st"> </span><span class="kw">max</span>(indices[<span class="dv">3</span>,])
EntrPartN &lt;-<span class="st"> </span>indices[<span class="dv">4</span>,] <span class="op">/</span><span class="st"> </span><span class="kw">max</span>(indices[<span class="dv">4</span>,])

indicesN &lt;-
<span class="st">  </span><span class="kw">data.frame</span>(<span class="kw">rbind</span>(XieBeniN, FukSugN, 
                   CoefPartN, EntrPartN))
indicesN &lt;-<span class="st"> </span>(indicesN) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>

indices2N &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">sum</span>(indicesN[, <span class="dv">1</span>]))
indices3N &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">sum</span>(indicesN[, <span class="dv">2</span>]))
indices4N &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">sum</span>(indicesN[, <span class="dv">3</span>]))

indices2N
<span class="co">#&gt; [1] 1,54</span>
indices3N
<span class="co">#&gt; [1] 1,86</span>
indices4N
<span class="co">#&gt; [1] 2,06</span></code></pre></div>
<p>El índice resumen se optimiza para la estructura conformada por dos clúster. Para realizar mapas de la clasificación, primero se debe extraer los datos de las clases delimitadas con el algoritmo <em>fuzzy k-means</em> y combinar con la base de datos inicial en la cual sólo se dejan las coordenadas. Posteriormente se transforma la base (<code>base_am</code>) a un objeto de clase <code>sf</code> y luego se grafican con el paquete <code>tmap</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">base_am &lt;-
<span class="st">  </span><span class="kw">cbind</span>(
    pred_am[, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],
    <span class="st">&quot;2clases&quot;</span> =<span class="st"> </span>clases2<span class="op">$</span>cluster,
    <span class="st">&quot;3clases&quot;</span> =<span class="st"> </span>clases3<span class="op">$</span>cluster,
    <span class="st">&quot;4clases&quot;</span> =<span class="st"> </span>clases4<span class="op">$</span>cluster
  )
<span class="kw">head</span>(base_am)
<span class="co">#&gt; x y 2clases 3clases 4clases</span>
<span class="co">#&gt; 1 312433 5800234 1 1 1</span>
<span class="co">#&gt; 2 312423 5800244 1 1 1</span>
<span class="co">#&gt; 3 312433 5800244 1 1 1</span>
<span class="co">#&gt; [ reached &#39;max&#39;</span>
    <span class="op">/</span><span class="st"> </span><span class="kw">getOption</span>(<span class="st">&quot;max.print&quot;</span>) <span class="op">--</span>
omitted <span class="dv">3</span> rows ]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">base_am &lt;-<span class="st"> </span><span class="kw">st_as_sf</span>(base_am, 
                    <span class="dt">coords =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>), 
                    <span class="dt">crs =</span> <span class="dv">32721</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="kw">tm_shape</span>(base_am) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="st">&quot;2clases&quot;</span>, <span class="dt">title =</span> <span class="st">&quot;Clasifición&quot;)</span></code></pre></div>
<p><img src="figuras/figLibro/tmapclasificacion-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="predicción-con-múltiples-capas-de-datos-1" class="section level2">
<h2><span class="header-section-number">5.7</span> Predicción con múltiples capas de datos</h2>
<p>En esta sección también se usa la base de datos <strong>Pred2.txt</strong> que contiene mediciones de conductividad eléctrica aparente en dos profundidades 0-30 cm (CE30) y 0-90 cm (CE90), elevación (Elev), profundidad de suelo (Pe) y rendimiento de trigo (Tg). La matriz de datos está conformada por n=482 sitios (filas) y p=7 variables (columnas).</p>
<p>Adicionalmente, para realizar la interpolación utilizando información de las covariables es necesario que la grilla de predicción contenga los valores de las coordenadas y de las covariables. El archivo <strong>grilla_am.txt</strong> contiene estos datos. A continuación, se cargan ambas bases de datos y transforma a objetos de clase <code>sf</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pred &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;datos/Pred2.txt&quot;</span>, 
                   <span class="dt">header =</span> <span class="ot">TRUE</span>)
pred &lt;-<span class="st"> </span><span class="kw">st_as_sf</span>(pred, <span class="dt">coords =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>), 
                 <span class="dt">crs =</span> <span class="dv">32721</span>)
<span class="kw">head</span>(pred)
<span class="co">#&gt; Simple feature collection with 6 features</span>
and <span class="dv">5</span> fields
<span class="co">#&gt; geometry type: POINT</span>
<span class="co">#&gt; dimension: XY</span>
<span class="co">#&gt; bbox: xmin: 312000 ymin: 5800000 xmax:</span>
<span class="dv">312000</span> ymax<span class="op">:</span><span class="st"> </span><span class="dv">5800000</span>
<span class="co">#&gt; epsg (SRID): 32721</span>
<span class="co">#&gt; proj4string: </span>
    <span class="op">+</span><span class="st"> </span>proj=utm 
    <span class="op">+</span><span class="st"> </span>zone=<span class="dv">21</span> 
    <span class="op">+</span><span class="st"> </span>south
<span class="op">+</span>datum=WGS84 <span class="op">+</span>units=m <span class="op">+</span>no_defs
<span class="co">#&gt; First 3 features:</span>
<span class="co">#&gt; Pe Elev CE30 CE90 Tg geometry</span>
<span class="co">#&gt; 1 80 161 21,8 30,6 4,19 POINT (312283</span>
<span class="dv">5800205</span><span class="er">)</span>
<span class="co">#&gt; 2 40 161 30,3 17,9 4,00 POINT (312257</span>
<span class="dv">5800229</span><span class="er">)</span>
<span class="co">#&gt; [ reached &#39;max&#39;</span>
    <span class="op">/</span><span class="st"> </span><span class="kw">getOption</span>(<span class="st">&quot;max.print&quot;</span>) <span class="op">--</span>
omitted <span class="dv">1</span> rows ]
grilla &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;datos/grilla_am.txt&quot;</span>, 
                     <span class="dt">header =</span> <span class="ot">TRUE</span>)
grilla &lt;-<span class="st"> </span><span class="kw">st_as_sf</span>(pred, <span class="dt">coords =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>), 
                   <span class="dt">crs =</span> <span class="dv">32721</span>)</code></pre></div>
<div id="kriging-con-deriva-externa" class="section level3">
<h3><span class="header-section-number">5.7.1</span> Kriging con deriva externa</h3>
<p>En las siguientes líneas de se realiza el ajuste del semivariograma empírico contemplando una tendencia dada por las covariables CE30, CE90, Elev y Pe y se realiza el ajuste de semivariogramas teóricos. Finalmente, se grafican ambos semivariogramas. Los resultados muestran que el modelo de mejor ajuste fue el exponencial. Los parámetros obtenidos fueron nugget (<span class="math inline">\(C_0=0.16\)</span>), sill parcial (<span class="math inline">\(C=0.55\)</span>) y rango (80 m). Nota: bajo la columna “psill”, para la fila Nugget, se debe leer el valor <span class="math inline">\(C_0\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">semiv_ked &lt;-<span class="st"> </span><span class="kw">variogram</span>(
  Tg <span class="op">~</span><span class="st"> </span>CE30 <span class="op">+</span><span class="st"> </span>CE90 <span class="op">+</span><span class="st"> </span>Elev <span class="op">+</span><span class="st"> </span>Pe, pred
  )
v.fit_vut_ked &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">fit.variogram</span>(semiv_ked , 
                <span class="kw">vgm</span>(<span class="kw">c</span>(<span class="st">&quot;Exp&quot;</span>, <span class="st">&quot;Sph&quot;</span>, <span class="st">&quot;Gau&quot;</span>)))
                               
v.fit_vut_ked
<span class="co">#&gt;   model psill range</span>
<span class="co">#&gt; 1   Nug 0,163   0,0</span>
<span class="co">#&gt; 2   Exp 0,549  80,7</span>
<span class="kw">plot</span>(semiv_ked , v.fit_vut_ked)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-88-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>Para realizar la interpolación espacial se utiliza también la función <code>krige()</code> y se especifica la tendencia con las covariables en la fórmula. En este caso la predicción se realiza también en un contexto local (argumentos <code>nmin</code> y <code>nmax</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">kriging_ed &lt;-<span class="st"> </span><span class="kw">krige</span>(
  Tg <span class="op">~</span><span class="st"> </span>CE30 <span class="op">+</span><span class="st"> </span>CE90 <span class="op">+</span><span class="st"> </span>Elev <span class="op">+</span><span class="st"> </span>Pe,
  pred,
  grilla,
  <span class="dt">model =</span> v.fit_vut_ked,
  <span class="dt">nmin =</span> <span class="dv">7</span>,
  <span class="dt">nmax =</span> <span class="dv">25</span>
)
<span class="co">#&gt; [using universal kriging]</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
prediccionKED &lt;-
<span class="st">  </span><span class="kw">tm_shape</span>(kriging_ed) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="st">&quot;var1.pred&quot;</span>, <span class="dt">style =</span> <span class="st">&quot;cont&quot;</span>,
          <span class="dt">title =</span> <span class="st">&quot;Predicción KED&quot;</span>)

varianzaKED &lt;-
<span class="st">  </span><span class="kw">tm_shape</span>(kriging_o) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="st">&quot;var1.var&quot;</span>, <span class="dt">style =</span> <span class="st">&quot;cont&quot;</span>,
          <span class="dt">title =</span> <span class="st">&quot;Varianza KED&quot;</span>) 

<span class="kw">tmap_arrange</span>(prediccionKED, varianzaKED)</code></pre></div>
<p><img src="figuras/figLibro/tmapKED-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
</div>
<div id="kriging-desde-modelo-de-regresión" class="section level3">
<h3><span class="header-section-number">5.7.2</span> Kriging desde modelo de regresión</h3>
<p>Para realizar la interpolación por el método kriging regresión primero se ajusta un modelo lineal de regresión entre la variable Tg y las covariables CE30, CE90, Elev y Pe.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mlr &lt;-<span class="st"> </span><span class="kw">lm</span>(Tg <span class="op">~</span><span class="st"> </span>CE30 <span class="op">+</span><span class="st"> </span>CE90 <span class="op">+</span><span class="st"> </span>Elev <span class="op">+</span><span class="st"> </span>Pe, pred)</code></pre></div>
<p>A partir del modelo ajustado se obtienen los residuos que son incorporados al objeto <code>pred</code>. Luego sobre estos residuos se modela el semivariograma empírico y teórico. Los resultados muestran que los valores estimados de los parámetros del semivariograma son similares a los obtenidos en el caso anterior. Esto es esperable ya que ambas aproximaciones son equivalentes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pred<span class="op">$</span>residuos &lt;-<span class="st"> </span>mlr<span class="op">$</span>residuals
<span class="kw">names</span>(pred)
<span class="co">#&gt; [1] &quot;Pe&quot; &quot;Elev&quot; &quot;CE30&quot; &quot;CE90&quot; &quot;Tg&quot;</span>
<span class="st">&quot;geometry&quot;</span> <span class="st">&quot;residuos&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">semiv_rk &lt;-<span class="st"> </span><span class="kw">variogram</span>(residuos <span class="op">~</span><span class="st"> </span><span class="dv">1</span> , pred)

v.fit_vut_rk &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">fit.variogram</span>(semiv_rk , 
                <span class="kw">vgm</span>(<span class="kw">c</span>(<span class="st">&quot;Exp&quot;</span>, <span class="st">&quot;Sph&quot;</span>, <span class="st">&quot;Gau&quot;</span>)))
v.fit_vut_rk
<span class="co">#&gt;   model psill range</span>
<span class="co">#&gt; 1   Nug 0,163   0,0</span>
<span class="co">#&gt; 2   Exp 0,549  80,7</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(semiv_rk , v.fit_vut_rk)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-93-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>Finalmente se realiza la predicción en la grilla de los residuos y esta es sumada a la predicción del modelo de regresión ajustado inicialmente para obtener los valores predichos finales.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">kgres &lt;-<span class="st"> </span><span class="kw">krige</span>(residuos <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, pred, 
               grilla, <span class="dt">model =</span> v.fit_vut_rk)
<span class="co">#&gt; [using ordinary kriging]</span>
grilla<span class="op">$</span>RK_pred &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">predict</span>(mlr, <span class="dt">newdata =</span> grilla) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span>kgres<span class="op">$</span>var1.pred</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="kw">tm_shape</span>(grilla) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="st">&quot;RK_pred&quot;</span>, <span class="dt">style =</span> <span class="st">&quot;cont&quot;</span>,
          <span class="dt">title =</span> <span class="st">&quot;Predicción RK&quot;</span>)</code></pre></div>
<p><img src="figuras/figLibro/tmapRK-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>
</div>
<div id="árboles-aleatorios" class="section level3">
<h3><span class="header-section-number">5.7.3</span> Árboles aleatorios</h3>
<p>Para este método primero se ajusta el algoritmo <em>random forest</em> utilizando para ello el paquete <code>caret</code>. Para ello se optimizará el parámetro <code>mtry</code> mediante un proceso de validación cruzada. Los valores prbados de <code>mtry</code> se especifican en el objeto que lleva el mismo nombre. Con la función <code>fitControl()</code> se estable el tipo de validación cruzada, en este caso k-fold con k=10. Además, se permite el paralelizado del proceso en caso de ser necesario (<code>allowParallel=T</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtry &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">mtry =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>))
fitControl &lt;-<span class="st"> </span><span class="kw">trainControl</span>(<span class="dt">method =</span> <span class="st">&quot;cv&quot;</span>,
                           <span class="dt">number =</span> <span class="dv">10</span>,
                           <span class="dt">allowParallel =</span> T)</code></pre></div>
<p>Las siguientes son las opciones de paralelizado que involucra los paquetes <code>parallel</code> y <code>doParallel</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(parallel)
<span class="kw">library</span>(doParallel)
cluster &lt;-<span class="st"> </span><span class="kw">makeCluster</span>(<span class="kw">max</span>(<span class="dv">1</span>, <span class="kw">detectCores</span>() <span class="op">-</span><span class="st"> </span><span class="dv">1</span>))
<span class="kw">registerDoParallel</span>(cluster)</code></pre></div>
<p>El ajuste del <em>random forest</em> se realiza con la función <code>train()</code> la cual requiere entre otros especifica la fórmula o modelo, la base de datos a utilizar, el algoritmo (<code>rf</code>, random forest), grilla de valores de hiperparámetros a evaluar (objeto <code>mtry</code>) y opciones de la validación.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">7</span>)
train_rf &lt;-<span class="st"> </span><span class="kw">train</span>(
  Tg <span class="op">~</span><span class="st"> </span>CE30 <span class="op">+</span><span class="st"> </span>CE90 <span class="op">+</span><span class="st"> </span>Elev <span class="op">+</span><span class="st"> </span>Pe,
  <span class="dt">data =</span> pred,
  <span class="dt">method =</span> <span class="st">&quot;rf&quot;</span>,
  <span class="dt">tuneGrid =</span> mtry,
  <span class="dt">trControl =</span> fitControl
)</code></pre></div>
<p>Luego de ajustar el modelo de RF se procede a obtener los residuos y el ajuste de los semivariogramas.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pred<span class="op">$</span>residuosRF &lt;-<span class="st"> </span>
<span class="st">  </span>pred<span class="op">$</span>Tg <span class="op">-</span><span class="st"> </span><span class="kw">predict</span>(train_rf, <span class="dt">newdata =</span> pred)

semiv_RFk &lt;-<span class="st"> </span><span class="kw">variogram</span>(residuosRF <span class="op">~</span><span class="st"> </span><span class="dv">1</span> , pred)
<span class="kw">plot</span>(semiv_RFk)

v.fit_vut_RFk &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">fit.variogram</span>(semiv_RFk , 
                <span class="kw">vgm</span>(<span class="kw">c</span>(<span class="st">&quot;Exp&quot;</span>, <span class="st">&quot;Sph&quot;</span>, <span class="st">&quot;Gau&quot;</span>)))
<span class="kw">plot</span>(semiv_RFk , v.fit_vut_RFk)</code></pre></div>
<p><img src="figuras/figLibro/unnamed-chunk-98-1.png" width="\linewidth" style="display: block; margin: auto;" /><img src="figuras/figLibro/unnamed-chunk-98-2.png" width="\linewidth" style="display: block; margin: auto;" /></p>
<p>Finalmente se realiza la predicción de los residuos sobre la grilla y se suman a la predicción del modelo de random forest ajustado inicialmente.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">kgresRF &lt;-<span class="st"> </span><span class="kw">krige</span>(residuosRF <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, pred, 
                 grilla, <span class="dt">model =</span> v.fit_vut_RFk)
<span class="co">#&gt; [using ordinary kriging]</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="kw">tm_shape</span>(grilla) <span class="op">+</span>
<span class="st">  </span><span class="kw">tm_dots</span>(<span class="st">&quot;RK_pred&quot;</span>, <span class="dt">style =</span> <span class="st">&quot;cont&quot;</span>,
          <span class="dt">title =</span> <span class="st">&quot;Predicción RFK&quot;</span>) </code></pre></div>
<p><img src="figuras/figLibro/tmapRFK-1.png" width="\linewidth" style="display: block; margin: auto;" /></p>

</div>
</div>
</div>
<h3>Referencias</h3>
<div id="refs" class="references">
<div id="ref-Cordoba2013">
<p>Córdoba, Mariano, Cecilia Bruno, José Luis Costa, and Mónica Balzarini. 2013. “Subfield management class delineation using cluster analysis from spatial principal components of soil variables.” <em>Computers and Electronics in Agriculture</em> 97 (September). Elsevier: 6–14. doi:<a href="https://doi.org/10.1016/j.compag.2013.05.009">10.1016/j.compag.2013.05.009</a>.</p>
</div>
<div id="ref-R-e1071">
<p>Meyer, David, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel, and Friedrich Leisch. 2019. <em>E1071: Misc Functions of the Department of Statistics, Probability Theory Group (Formerly: E1071), Tu Wien</em>. <a href="https://CRAN.R-project.org/package=e1071" class="uri">https://CRAN.R-project.org/package=e1071</a>.</p>
</div>
</div>
<script>
/*
Sorts the references alphabetically.
Modified from code by Yvonne Aburrow.
*/
$(function(){
    var elems = $('#refs').children('div').remove();
    elems.sort(function (a, b) {
        return $(b).children('p').html().toUpperCase() > $(a).children('p').html().toUpperCase() ? -1 : 1;
    });
    $('#refs').append(elems);
})
</script>
            </section>

          </div>
        </div>
      </div>
<a href="predicción-con-múltiples-capas-de-datos.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="implementación-con-infostat.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": null,
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["PROTRI2018-VariabilidadEspacial.pdf", "PROTRI2018-VariabilidadEspacial.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
